/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { AccordianSection } from "./components/es-accordian/types";
import { RenderFunction } from "./types";
import { BadgeVariant } from "./components/es-badge/es-badge";
import { ButtonVariant } from "./components/buttons/types";
import { EsCalloutVariant } from "./components/es-callout/es-callout";
import { IconDescription } from "./components/es-icon/types";
import { CornerBannerVariant } from "./components/es-corner-banner/es-corner-banner";
import { CounterColor, CounterVariant } from "./components/es-counter/types";
import { PageChangeEventType } from "./components/es-pagination/types";
import { Constrain, Placement } from "./components/es-popover/types";
import { Checkpoint, CheckpointState } from "./components/es-progression/types";
import { Status } from "./components/es-status/es-status";
import { ClickRow, JumpOptions, LoadWindow, TableCells, TableSort } from "./components/tables/types";
import { Tab } from "./components/es-tabs/types";
import { Toast, ToastLevel, ToastOptions } from "./components/toast/types";
import { WizardPage } from "./components/es-wizard/types";
export { AccordianSection } from "./components/es-accordian/types";
export { RenderFunction } from "./types";
export { BadgeVariant } from "./components/es-badge/es-badge";
export { ButtonVariant } from "./components/buttons/types";
export { EsCalloutVariant } from "./components/es-callout/es-callout";
export { IconDescription } from "./components/es-icon/types";
export { CornerBannerVariant } from "./components/es-corner-banner/es-corner-banner";
export { CounterColor, CounterVariant } from "./components/es-counter/types";
export { PageChangeEventType } from "./components/es-pagination/types";
export { Constrain, Placement } from "./components/es-popover/types";
export { Checkpoint, CheckpointState } from "./components/es-progression/types";
export { Status } from "./components/es-status/es-status";
export { ClickRow, JumpOptions, LoadWindow, TableCells, TableSort } from "./components/tables/types";
export { Tab } from "./components/es-tabs/types";
export { Toast, ToastLevel, ToastOptions } from "./components/toast/types";
export { WizardPage } from "./components/es-wizard/types";
export namespace Components {
    /**
     * Optionally collapsible sectioned view. Each section can be targeted via a part.
     */
    interface EsAccordian {
        /**
          * An array of sections to display.
         */
        "sections": AccordianSection[];
        /**
          * Display numbered counters beside each title.
         */
        "steps": boolean;
    }
    interface EsBackdrop {
        "close": () => Promise<void>;
        "preventOverscroll": boolean;
        "renderNode": (node: RenderFunction) => Promise<void>;
        "showBackdrop": boolean;
    }
    /**
     * Display a counter or dot beside a component to indicate action being required.
     */
    interface EsBadge {
        /**
          * Choose the color variant of the badge
         */
        "color": HTMLEsCounterElement['color'];
        /**
          * What number to display in the counter (or if the dot should display)
         */
        "count": number;
        /**
          * Show the dot and counter even if the count 0 (or negative)
         */
        "showZero": boolean;
        /**
          * The base size (in px) of the counter (has no effect on the dot)
         */
        "size"?: number;
        /**
          * Select the display variant of the badge
         */
        "variant": BadgeVariant;
    }
    /**
     * A button.
     */
    interface EsButton {
        /**
          * If the button is disabled. Prevents the user from interacting with the button: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * The default behavior of the button.
         */
        "type": string;
        /**
          * Which styling variant to use.
         */
        "variant": ButtonVariant;
    }
    /**
     * Anchor link version of es-button, wraps a `Link` from `@eventstore-ui/router`.
     */
    interface EsButtonLink {
        /**
          * Class for the contained anchor element
         */
        "anchorClass"?: string;
        /**
          * Id for the contained anchor element
         */
        "anchorId"?: string;
        /**
          * Role for the contained anchor element
         */
        "anchorRole"?: string;
        /**
          * Tab Index for the contained anchor element
         */
        "anchorTabIndex"?: string;
        /**
          * Title for the contained anchor element
         */
        "anchorTitle"?: string;
        /**
          * If the link is disabled. Prevents the user from interacting with the link: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * Link is for an external site
         */
        "external"?: boolean;
        /**
          * If the button should navigate within the router context, or force a refresh.
         */
        "forceRefresh"?: boolean;
        /**
          * Target for link (eg: target="_blank")
         */
        "target"?: string;
        /**
          * Where the button should link to.
         */
        "url"?: string;
        /**
          * Which styling variant to use
         */
        "variant": ButtonVariant;
    }
    /**
     * Calls out a piece of information.
     */
    interface EsCallout {
        /**
          * Heading text.
         */
        "heading": string;
        /**
          * Override the variant icon.
         */
        "icon"?: IconDescription;
        /**
          * Which color set to use.
         */
        "variant": EsCalloutVariant;
    }
    /**
     * Copies the text passed as a child when clicked.
     */
    interface EsCopy {
        /**
          * Manually triggers the copy of the inner text.
         */
        "copy": () => Promise<void>;
    }
    /**
     * Display a banner with text in the corner.
     */
    interface EsCornerBanner {
        /**
          * Which styling variant to use.
         */
        "variant": CornerBannerVariant;
        /**
          * X location of the banner.
         */
        "x": 'left' | 'right';
        /**
          * Y location of the banner
         */
        "y": 'top' | 'bottom';
    }
    /**
     * A pill display of an number, that pulses on change. Caps out at 999.
     */
    interface EsCounter {
        /**
          * Choose the color variant of the counter
         */
        "color"?: CounterColor;
        /**
          * The number to display
         */
        "count": number;
        /**
          * The height of the counter that the rest of the dimensions scale from
         */
        "size": number;
        /**
          * The display style of the counter.
         */
        "variant": CounterVariant;
    }
    /**
     * Displays an icon loaded from the `iconStore`. An icon named "spinner" will automatically spin.
     * See [IconStore](/components/variables/iconStore) for details on how to load icons.
     */
    interface EsIcon {
        /**
          * Rotate the icon to a speciied angle.
         */
        "angle": number;
        /**
          * Which icon to display.
         */
        "icon": IconDescription;
        /**
          * The hight and width to scale the icon to.
         */
        "size": number;
        /**
          * Apply a spin animation.
         */
        "spin"?: boolean;
        /**
          * When spinning, should it spin clockwise or anticlockwise.
         */
        "spinDirection": 'clockwise' | 'antiClockwise';
        /**
          * Provides a promise that resolves at the end of a single spin, if the icon is spinning.
         */
        "spinEnd": () => Promise<void>;
    }
    /**
     * Display a row of five pulsing dots, to indicate loading.
     */
    interface EsLoadingDots {
    }
    /**
     * Displays a grey block to placehold loading text.
     */
    interface EsLoadingText {
        /**
          * The expected loaded text length.
         */
        "expectedLength": number;
        /**
          * Adds a random number of chars (up to the passed amount)
         */
        "variance"?: number;
    }
    /**
     * A pop up modal for overlaying information, warnings and confirmations.
     * Traps focus within the modal, and returns focus to previous location when closed.
     * Pair with an [`es-portal`](/components/components/es-portal) to open and close.
     */
    interface EsModal {
        /**
          * If the modal should have a footer.
         */
        "footer": boolean;
        /**
          * If the modal should have a header.
         */
        "header": boolean;
    }
    /**
     * Page navigation with ability to jump to first and last pages with `pageCount` is provided.
     */
    interface EsPagination {
        /**
          * Current Page.
         */
        "current": number;
        /**
          * Number of pages.
         */
        "pageCount"?: number;
    }
    /**
     * Attaches a portaled popover, attached to the parent node. Can be used to create dropdowns, tooltips etc. The parent scoped shadow styles are copied to the created portals shadow styles, to allow styling popover contents externally.
     */
    interface EsPopover {
        /**
          * If the popover should render an arrow.
         */
        "arrow": boolean;
        /**
          * Pass an element to attach the popover to. (Defaults to the parent element.)
         */
        "attachTo"?: HTMLElement;
        /**
          * Constrain the size of the popover to the size of the attachment node.
         */
        "autoSize": Constrain;
        /**
          * If the popover should overlay a backdrop, to prevent external clicks.
         */
        "backdrop": boolean;
        /**
          * If the popover should request to close when focus is lost
         */
        "closeOnBlur": boolean;
        /**
          * If the popover should request to close when clicked outside
         */
        "closeOnClickOutside": boolean;
        /**
          * If the popover should request to close when esc is pressed
         */
        "closeOnEsc": boolean;
        /**
          * If the popover should request to close when the attachment element scrolls out of view
         */
        "closeOnScrollEscape": boolean;
        /**
          * Constrain the size of the popover inner to the size of the window.
         */
        "constrain": Constrain;
        /**
          * An array of allowed placements or enable / disable
         */
        "flip"?: Placement[] | boolean;
        /**
          * If the popover should hide itself when the attachment element scrolls out of view
         */
        "hideOnScrollEscape": boolean;
        /**
          * The maximum height to constrain to.
         */
        "maxHeight": number;
        /**
          * The maximum width to constrain to.
         */
        "maxWidth": number;
        /**
          * The offset away from the attachement element in px.
         */
        "offset": number;
        /**
          * Toggles if the popover is open or not.
         */
        "open": boolean;
        /**
          * Where to place the popover in relation to the attachment point.
         */
        "placement": Placement;
        /**
          * Class name for the popper
         */
        "popperClass"?: string;
        /**
          * A query selecter to select the element to portal the popper to.
         */
        "target": string;
        /**
          * If the popover should trap focus within, and return focus on close.
         */
        "trapFocus": boolean;
        /**
          * What zIndex to place the popover in.
         */
        "zIndex"?: number;
    }
    interface EsPopper {
        "backdrop": boolean;
        "loaded": () => Promise<boolean>;
        "trapFocus": boolean;
    }
    interface EsPopperInner {
    }
    interface EsPopperX {
    }
    interface EsPopperY {
    }
    /**
     * Portals the passed node to a different part of the document. Note that portal does not transfer shadow scoped styles, unlike `es-popover`, so any portaled elements should be self contained.
     */
    interface EsPortal {
        "attachElement": () => Promise<void>;
        /**
          * If the portal should overlay a backdrop, to prevent external clicks.
         */
        "backdrop": boolean;
        "detatchElement": () => Promise<void>;
        /**
          * If the element is portaled or not.
         */
        "open": boolean;
        /**
          * If the portal should prevent overscroll
         */
        "preventOverscroll": boolean;
        /**
          * The element to render.
         */
        "renderElement": RenderFunction;
        /**
          * A query selector to select the location to portal to.
         */
        "target": string;
    }
    /**
     * A wizard progression bar.
     */
    interface EsProgression {
        /**
          * A list of checkpoints to display.
         */
        "checkpoints": Checkpoint[];
        /**
          * Set custom colors for all checkpoints
         */
        "colors"?: Partial<Record<CheckpointState, string>>;
        /**
          * Set custom icons for all checkpoints
         */
        "icons"?: Partial<Record<CheckpointState, IconDescription>>;
        /**
          * The current active location.
         */
        "location": string;
        /**
          * Disable interactivity.
         */
        "readonly"?: boolean;
    }
    /**
     * Wraps a [ResizeObserver](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver) to allow tracking `DOMRect` dimensions
     */
    interface EsResizeObserver {
    }
    interface EsStatus {
        "status": Status;
    }
    /**
     * Create a table from data.
     */
    interface EsTable {
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any, any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: string[];
        /**
          * Pass extra props to cells
         */
        "extraCellProps"?: (key: string, data: any) => Record<string, any>;
        /**
          * Sync function for extracting the data from the row. By default, it assumes you passed an array of data as your columns.
         */
        "getCellData": (key: string) => any;
        /**
          * Do not render header.
         */
        "headless": boolean;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier": string;
        /**
          * A function to calculate a href from the cell data.
         */
        "linkRowTo"?: (row: any) => string;
        /**
          * Allows rendering a node after the row.
         */
        "renderExpansion": RenderFunction<[key: string]>;
        /**
          * A function to calculate the class or classes of the row from the cellData.
         */
        "rowClass": (
        row: any,
        key: string,
    ) => Record<string, boolean> | string | undefined;
        /**
          * If rows should be allowed to take focus
         */
        "rowTakesFocus"?: boolean;
        /**
          * An array of rows to render. Each item in the array is passed to getCellData, to allow passing keys or other identifiers.
         */
        "rows": any[];
        /**
          * How the table is sorted
         */
        "sort"?: TableSort;
        /**
          * Header sticks to scroll parent.
         */
        "stickyHeader": boolean;
    }
    /**
     * Render a single row data as a grid of information.
     */
    interface EsTableDetail {
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any, any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: Array<string>;
        /**
          * The data to render.
         */
        "data": any;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier": string;
    }
    /**
     * A default header for [`es-table-detail`](/components/components/es-table-detail).
     */
    interface EsTableDetailHeader {
        /**
          * Which cell to place in the top right as a list of actions.
         */
        "actionsCell": string;
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any, any>;
        /**
          * The data to render.
         */
        "data": any;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier": string;
        /**
          * Which cell to place as the title
         */
        "titleCell": string;
    }
    /**
     * Create a nested table from data.
     */
    interface EsTableNested {
        /**
          * A path to a the currently active row, to auto expand its parent and show it as selected.
         */
        "activePath"?: string[];
        /**
          * Function to decide if a row can take expand, to show a nested table.
         */
        "canExpand": (key: string, data: any, depth: number) => boolean;
        /**
          * Function to decide if a row can expand more, to show more rows in the nested table.
         */
        "canExpandMore": (key: string, count: number) => boolean;
        /**
          * A record of table cell definitions.Some built in cells are cells are available for use: - `--borderless`: A blank placeholder cell with no border, for aligning with the parent cell. - `--no-pad`: A blank placeholder cell, for aligning with the parent cell. - `--expander`: The expander button.
         */
        "cells": TableCells<any, any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: string[];
        /**
          * Number of rows to be expanded by default
         */
        "defaultExpanded"?: (key: string, depth: number) => number;
        /**
          * Number number of rows to display in expansion
         */
        "expandBy": number;
        /**
          * Pass extra props to cells
         */
        "extraCellProps"?: (key: string, data: any) => Record<string, any>;
        /**
          * Sync function for extracting the data from the row. By default, it assumes you passed an array of data as your columns.
         */
        "getCellData"?: (key: string) => any;
        /**
          * Sync function for extracting the data from the nested row. By default, it assumes you passed an array of data as your columns.
         */
        "getNestedCellData"?: (key: string) => any;
        /**
          * Sync function for extracting a list of rows for the nested table
         */
        "getNestedRows"?: (key: string, count: number) => any[] | undefined;
        /**
          * Do not render header.
         */
        "headless": boolean;
        /**
          * A function to calculate a href from the cell data.
         */
        "linkRowTo"?: (row: any) => string;
        /**
          * async function for loading nested data when a row is expanded.
         */
        "loadNested"?: (key: string, data: any) => Promise<void>;
        /**
          * The order and keys of the cells to be rendered in a nested table. If omitted, all cells will be rendered.
         */
        "nestedColumns"?: string[];
        /**
          * Passed to cell renderer as `parent`.
         */
        "nestedIdentifier": string;
        /**
          * If the nested rows should be allowed to take focus.
         */
        "nestedRowTakesFocus"?: boolean;
        /**
          * Passed to cell renderer as `parent`.
         */
        "outerIdentifier": string;
        /**
          * A function to calculate the class or classes of the row from the cellData.
         */
        "rowClass": (
        row: any,
        key: string,
    ) => Record<string, boolean> | string | undefined;
        /**
          * If rows should be allowed to take focus
         */
        "rowTakesFocus"?: boolean;
        /**
          * An array of rows to render. Each item in the array is passed to getCellData, to allow passing keys or other identifiers.
         */
        "rows": any[];
        /**
          * Header sticks to scroll parent.
         */
        "stickyHeader": boolean;
        /**
          * If clicking a row should expand it.
         */
        "toggleRowOnClick": boolean;
    }
    /**
     * Create a virtualized table from data.
     */
    interface EsTableVirtualized {
        /**
          * The height (in pixels) of the after
         */
        "afterHeight": number;
        /**
          * The height (in pixels) of the before
         */
        "beforeHeight": number;
        /**
          * Groups rows into blocks
         */
        "blockSize": number;
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any, any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: string[];
        /**
          * Pass extra props to cells
         */
        "extraCellProps"?: (key: string, data: any) => Record<string, any>;
        /**
          * Sync function for extracting the data from the row. By default, it assumes you passed an array of data as your columns.
         */
        "getCellData": (key: string, index: number) => any;
        /**
          * Sync function for converting an index into a key
         */
        "getKeyFromIndex": (index: number) => string;
        /**
          * The height (in pixels) of the header
         */
        "headerHeight": number;
        /**
          * Do not render header.
         */
        "headless": boolean;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier": string;
        /**
          * Jump to the passed row, with smooth scroll and highlight, if specified.
         */
        "jumpToRow": (index: number, { highlight, smooth }?: Partial<JumpOptions>) => Promise<void>;
        /**
          * A function to calculate a href from the cell data.
         */
        "linkRowTo"?: (row: any) => string;
        /**
          * The size of the grid rows before starting a reflow
         */
        "reflowSize": number;
        /**
          * Display in a row after the last row
         */
        "renderAfter"?: RenderFunction;
        /**
          * Display in a row before the first row
         */
        "renderBefore"?: RenderFunction;
        /**
          * A function to calculate the class or classes of the row from the cellData.
         */
        "rowClass": (
        row: any,
        key: string,
        index: number,
    ) => Record<string, boolean> | string | undefined;
        /**
          * The total number of rows
         */
        "rowCount": number;
        /**
          * The height (in pixels) of the row
         */
        "rowHeight": number;
        /**
          * If rows should be allowed to take focus
         */
        "rowTakesFocus"?: boolean;
        /**
          * If the table should lock scroll on appending events
         */
        "scrollLock"?: boolean;
        /**
          * How the table is sorted
         */
        "sort"?: TableSort;
        /**
          * Header sticks to scroll parent.
         */
        "stickyHeader": boolean;
        /**
          * The size of the window to render
         */
        "windowSize": number;
    }
    /**
     * A tabbed panel. Each panel can be targeted via a slot.
     */
    interface EsTabs {
        /**
          * The currently active panel. By default it will take from the passed activeParam, or the first tab.
         */
        "active"?: string;
        /**
          * Reflect the active tab to a search param of name. Set to false to disable.
         */
        "activeParam": string | false;
        /**
          * Icon to be rendered between each tab.
         */
        "interTabIcon"?: IconDescription;
        /**
          * thu size of the icon to be rendered between each tab.
         */
        "interTabIconSize": number;
        /**
          * A list of tabs.
         */
        "tabs": Tab[];
    }
    /**
     * A button with an icon that displays the state of a async action on click.
     */
    interface EsThinkingButton {
        /**
          * The async action to be called on click.
         */
        "action": (e: MouseEvent) => Promise<unknown>;
        /**
          * The icon to display when the action completed successfully.
         */
        "completeIcon": IconDescription;
        /**
          * The default icon to display when nothing is happening.
         */
        "defaultIcon": IconDescription;
        /**
          * If the button is disabled. Prevents the user from interacting with the button: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * The icon to display when the action errored out.
         */
        "failedIcon": IconDescription;
        /**
          * Optional text of the button
         */
        "text"?: string;
        /**
          * The icon to display when we are awaiting the action.
         */
        "thinkingIcon": IconDescription;
        /**
          * Which styling variant to use.
         */
        "variant": HTMLEsButtonElement['variant'];
    }
    interface EsToast {
        "close": () => Promise<void>;
        "count": Toast['count'];
        "icon": Toast['icon'];
        "level": ToastLevel;
    }
    interface EsToaster {
        "popToast": (level: ToastLevel | undefined, { message, title, duration, icon, onClick, }: ToastOptions) => Promise<() => void>;
    }
    /**
     * A multi step wizard. Each step can be targeted via a slot.
     */
    interface EsWizard {
        /**
          * The currently active page
         */
        "location": string;
        /**
          * A list of pages describing each step.
         */
        "pages": WizardPage[];
        /**
          * Offset the scroll to top on page change
         */
        "scrollOffset": number;
    }
}
export interface EsBackdropCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsBackdropElement;
}
export interface EsModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsModalElement;
}
export interface EsPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsPaginationElement;
}
export interface EsPopoverCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsPopoverElement;
}
export interface EsPopperCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsPopperElement;
}
export interface EsPortalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsPortalElement;
}
export interface EsProgressionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsProgressionElement;
}
export interface EsResizeObserverCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsResizeObserverElement;
}
export interface EsTableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsTableElement;
}
export interface EsTableNestedCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsTableNestedElement;
}
export interface EsTableVirtualizedCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsTableVirtualizedElement;
}
export interface EsTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsTabsElement;
}
declare global {
    /**
     * Optionally collapsible sectioned view. Each section can be targeted via a part.
     */
    interface HTMLEsAccordianElement extends Components.EsAccordian, HTMLStencilElement {
    }
    var HTMLEsAccordianElement: {
        prototype: HTMLEsAccordianElement;
        new (): HTMLEsAccordianElement;
    };
    interface HTMLEsBackdropElement extends Components.EsBackdrop, HTMLStencilElement {
    }
    var HTMLEsBackdropElement: {
        prototype: HTMLEsBackdropElement;
        new (): HTMLEsBackdropElement;
    };
    /**
     * Display a counter or dot beside a component to indicate action being required.
     */
    interface HTMLEsBadgeElement extends Components.EsBadge, HTMLStencilElement {
    }
    var HTMLEsBadgeElement: {
        prototype: HTMLEsBadgeElement;
        new (): HTMLEsBadgeElement;
    };
    /**
     * A button.
     */
    interface HTMLEsButtonElement extends Components.EsButton, HTMLStencilElement {
    }
    var HTMLEsButtonElement: {
        prototype: HTMLEsButtonElement;
        new (): HTMLEsButtonElement;
    };
    /**
     * Anchor link version of es-button, wraps a `Link` from `@eventstore-ui/router`.
     */
    interface HTMLEsButtonLinkElement extends Components.EsButtonLink, HTMLStencilElement {
    }
    var HTMLEsButtonLinkElement: {
        prototype: HTMLEsButtonLinkElement;
        new (): HTMLEsButtonLinkElement;
    };
    /**
     * Calls out a piece of information.
     */
    interface HTMLEsCalloutElement extends Components.EsCallout, HTMLStencilElement {
    }
    var HTMLEsCalloutElement: {
        prototype: HTMLEsCalloutElement;
        new (): HTMLEsCalloutElement;
    };
    /**
     * Copies the text passed as a child when clicked.
     */
    interface HTMLEsCopyElement extends Components.EsCopy, HTMLStencilElement {
    }
    var HTMLEsCopyElement: {
        prototype: HTMLEsCopyElement;
        new (): HTMLEsCopyElement;
    };
    /**
     * Display a banner with text in the corner.
     */
    interface HTMLEsCornerBannerElement extends Components.EsCornerBanner, HTMLStencilElement {
    }
    var HTMLEsCornerBannerElement: {
        prototype: HTMLEsCornerBannerElement;
        new (): HTMLEsCornerBannerElement;
    };
    /**
     * A pill display of an number, that pulses on change. Caps out at 999.
     */
    interface HTMLEsCounterElement extends Components.EsCounter, HTMLStencilElement {
    }
    var HTMLEsCounterElement: {
        prototype: HTMLEsCounterElement;
        new (): HTMLEsCounterElement;
    };
    /**
     * Displays an icon loaded from the `iconStore`. An icon named "spinner" will automatically spin.
     * See [IconStore](/components/variables/iconStore) for details on how to load icons.
     */
    interface HTMLEsIconElement extends Components.EsIcon, HTMLStencilElement {
    }
    var HTMLEsIconElement: {
        prototype: HTMLEsIconElement;
        new (): HTMLEsIconElement;
    };
    /**
     * Display a row of five pulsing dots, to indicate loading.
     */
    interface HTMLEsLoadingDotsElement extends Components.EsLoadingDots, HTMLStencilElement {
    }
    var HTMLEsLoadingDotsElement: {
        prototype: HTMLEsLoadingDotsElement;
        new (): HTMLEsLoadingDotsElement;
    };
    /**
     * Displays a grey block to placehold loading text.
     */
    interface HTMLEsLoadingTextElement extends Components.EsLoadingText, HTMLStencilElement {
    }
    var HTMLEsLoadingTextElement: {
        prototype: HTMLEsLoadingTextElement;
        new (): HTMLEsLoadingTextElement;
    };
    /**
     * A pop up modal for overlaying information, warnings and confirmations.
     * Traps focus within the modal, and returns focus to previous location when closed.
     * Pair with an [`es-portal`](/components/components/es-portal) to open and close.
     */
    interface HTMLEsModalElement extends Components.EsModal, HTMLStencilElement {
    }
    var HTMLEsModalElement: {
        prototype: HTMLEsModalElement;
        new (): HTMLEsModalElement;
    };
    /**
     * Page navigation with ability to jump to first and last pages with `pageCount` is provided.
     */
    interface HTMLEsPaginationElement extends Components.EsPagination, HTMLStencilElement {
    }
    var HTMLEsPaginationElement: {
        prototype: HTMLEsPaginationElement;
        new (): HTMLEsPaginationElement;
    };
    /**
     * Attaches a portaled popover, attached to the parent node. Can be used to create dropdowns, tooltips etc. The parent scoped shadow styles are copied to the created portals shadow styles, to allow styling popover contents externally.
     */
    interface HTMLEsPopoverElement extends Components.EsPopover, HTMLStencilElement {
    }
    var HTMLEsPopoverElement: {
        prototype: HTMLEsPopoverElement;
        new (): HTMLEsPopoverElement;
    };
    interface HTMLEsPopperElement extends Components.EsPopper, HTMLStencilElement {
    }
    var HTMLEsPopperElement: {
        prototype: HTMLEsPopperElement;
        new (): HTMLEsPopperElement;
    };
    interface HTMLEsPopperInnerElement extends Components.EsPopperInner, HTMLStencilElement {
    }
    var HTMLEsPopperInnerElement: {
        prototype: HTMLEsPopperInnerElement;
        new (): HTMLEsPopperInnerElement;
    };
    interface HTMLEsPopperXElement extends Components.EsPopperX, HTMLStencilElement {
    }
    var HTMLEsPopperXElement: {
        prototype: HTMLEsPopperXElement;
        new (): HTMLEsPopperXElement;
    };
    interface HTMLEsPopperYElement extends Components.EsPopperY, HTMLStencilElement {
    }
    var HTMLEsPopperYElement: {
        prototype: HTMLEsPopperYElement;
        new (): HTMLEsPopperYElement;
    };
    /**
     * Portals the passed node to a different part of the document. Note that portal does not transfer shadow scoped styles, unlike `es-popover`, so any portaled elements should be self contained.
     */
    interface HTMLEsPortalElement extends Components.EsPortal, HTMLStencilElement {
    }
    var HTMLEsPortalElement: {
        prototype: HTMLEsPortalElement;
        new (): HTMLEsPortalElement;
    };
    /**
     * A wizard progression bar.
     */
    interface HTMLEsProgressionElement extends Components.EsProgression, HTMLStencilElement {
    }
    var HTMLEsProgressionElement: {
        prototype: HTMLEsProgressionElement;
        new (): HTMLEsProgressionElement;
    };
    /**
     * Wraps a [ResizeObserver](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver) to allow tracking `DOMRect` dimensions
     */
    interface HTMLEsResizeObserverElement extends Components.EsResizeObserver, HTMLStencilElement {
    }
    var HTMLEsResizeObserverElement: {
        prototype: HTMLEsResizeObserverElement;
        new (): HTMLEsResizeObserverElement;
    };
    interface HTMLEsStatusElement extends Components.EsStatus, HTMLStencilElement {
    }
    var HTMLEsStatusElement: {
        prototype: HTMLEsStatusElement;
        new (): HTMLEsStatusElement;
    };
    /**
     * Create a table from data.
     */
    interface HTMLEsTableElement extends Components.EsTable, HTMLStencilElement {
    }
    var HTMLEsTableElement: {
        prototype: HTMLEsTableElement;
        new (): HTMLEsTableElement;
    };
    /**
     * Render a single row data as a grid of information.
     */
    interface HTMLEsTableDetailElement extends Components.EsTableDetail, HTMLStencilElement {
    }
    var HTMLEsTableDetailElement: {
        prototype: HTMLEsTableDetailElement;
        new (): HTMLEsTableDetailElement;
    };
    /**
     * A default header for [`es-table-detail`](/components/components/es-table-detail).
     */
    interface HTMLEsTableDetailHeaderElement extends Components.EsTableDetailHeader, HTMLStencilElement {
    }
    var HTMLEsTableDetailHeaderElement: {
        prototype: HTMLEsTableDetailHeaderElement;
        new (): HTMLEsTableDetailHeaderElement;
    };
    /**
     * Create a nested table from data.
     */
    interface HTMLEsTableNestedElement extends Components.EsTableNested, HTMLStencilElement {
    }
    var HTMLEsTableNestedElement: {
        prototype: HTMLEsTableNestedElement;
        new (): HTMLEsTableNestedElement;
    };
    /**
     * Create a virtualized table from data.
     */
    interface HTMLEsTableVirtualizedElement extends Components.EsTableVirtualized, HTMLStencilElement {
    }
    var HTMLEsTableVirtualizedElement: {
        prototype: HTMLEsTableVirtualizedElement;
        new (): HTMLEsTableVirtualizedElement;
    };
    /**
     * A tabbed panel. Each panel can be targeted via a slot.
     */
    interface HTMLEsTabsElement extends Components.EsTabs, HTMLStencilElement {
    }
    var HTMLEsTabsElement: {
        prototype: HTMLEsTabsElement;
        new (): HTMLEsTabsElement;
    };
    /**
     * A button with an icon that displays the state of a async action on click.
     */
    interface HTMLEsThinkingButtonElement extends Components.EsThinkingButton, HTMLStencilElement {
    }
    var HTMLEsThinkingButtonElement: {
        prototype: HTMLEsThinkingButtonElement;
        new (): HTMLEsThinkingButtonElement;
    };
    interface HTMLEsToastElement extends Components.EsToast, HTMLStencilElement {
    }
    var HTMLEsToastElement: {
        prototype: HTMLEsToastElement;
        new (): HTMLEsToastElement;
    };
    interface HTMLEsToasterElement extends Components.EsToaster, HTMLStencilElement {
    }
    var HTMLEsToasterElement: {
        prototype: HTMLEsToasterElement;
        new (): HTMLEsToasterElement;
    };
    /**
     * A multi step wizard. Each step can be targeted via a slot.
     */
    interface HTMLEsWizardElement extends Components.EsWizard, HTMLStencilElement {
    }
    var HTMLEsWizardElement: {
        prototype: HTMLEsWizardElement;
        new (): HTMLEsWizardElement;
    };
    interface HTMLElementTagNameMap {
        "es-accordian": HTMLEsAccordianElement;
        "es-backdrop": HTMLEsBackdropElement;
        "es-badge": HTMLEsBadgeElement;
        "es-button": HTMLEsButtonElement;
        "es-button-link": HTMLEsButtonLinkElement;
        "es-callout": HTMLEsCalloutElement;
        "es-copy": HTMLEsCopyElement;
        "es-corner-banner": HTMLEsCornerBannerElement;
        "es-counter": HTMLEsCounterElement;
        "es-icon": HTMLEsIconElement;
        "es-loading-dots": HTMLEsLoadingDotsElement;
        "es-loading-text": HTMLEsLoadingTextElement;
        "es-modal": HTMLEsModalElement;
        "es-pagination": HTMLEsPaginationElement;
        "es-popover": HTMLEsPopoverElement;
        "es-popper": HTMLEsPopperElement;
        "es-popper-inner": HTMLEsPopperInnerElement;
        "es-popper-x": HTMLEsPopperXElement;
        "es-popper-y": HTMLEsPopperYElement;
        "es-portal": HTMLEsPortalElement;
        "es-progression": HTMLEsProgressionElement;
        "es-resize-observer": HTMLEsResizeObserverElement;
        "es-status": HTMLEsStatusElement;
        "es-table": HTMLEsTableElement;
        "es-table-detail": HTMLEsTableDetailElement;
        "es-table-detail-header": HTMLEsTableDetailHeaderElement;
        "es-table-nested": HTMLEsTableNestedElement;
        "es-table-virtualized": HTMLEsTableVirtualizedElement;
        "es-tabs": HTMLEsTabsElement;
        "es-thinking-button": HTMLEsThinkingButtonElement;
        "es-toast": HTMLEsToastElement;
        "es-toaster": HTMLEsToasterElement;
        "es-wizard": HTMLEsWizardElement;
    }
}
declare namespace LocalJSX {
    /**
     * Optionally collapsible sectioned view. Each section can be targeted via a part.
     */
    interface EsAccordian {
        /**
          * An array of sections to display.
         */
        "sections": AccordianSection[];
        /**
          * Display numbered counters beside each title.
         */
        "steps"?: boolean;
    }
    interface EsBackdrop {
        "onClosed"?: (event: EsBackdropCustomEvent<any>) => void;
        "onRequestClose"?: (event: EsBackdropCustomEvent<any>) => void;
        "preventOverscroll"?: boolean;
        "showBackdrop"?: boolean;
    }
    /**
     * Display a counter or dot beside a component to indicate action being required.
     */
    interface EsBadge {
        /**
          * Choose the color variant of the badge
         */
        "color"?: HTMLEsCounterElement['color'];
        /**
          * What number to display in the counter (or if the dot should display)
         */
        "count": number;
        /**
          * Show the dot and counter even if the count 0 (or negative)
         */
        "showZero"?: boolean;
        /**
          * The base size (in px) of the counter (has no effect on the dot)
         */
        "size"?: number;
        /**
          * Select the display variant of the badge
         */
        "variant"?: BadgeVariant;
    }
    /**
     * A button.
     */
    interface EsButton {
        /**
          * If the button is disabled. Prevents the user from interacting with the button: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * The default behavior of the button.
         */
        "type"?: string;
        /**
          * Which styling variant to use.
         */
        "variant"?: ButtonVariant;
    }
    /**
     * Anchor link version of es-button, wraps a `Link` from `@eventstore-ui/router`.
     */
    interface EsButtonLink {
        /**
          * Class for the contained anchor element
         */
        "anchorClass"?: string;
        /**
          * Id for the contained anchor element
         */
        "anchorId"?: string;
        /**
          * Role for the contained anchor element
         */
        "anchorRole"?: string;
        /**
          * Tab Index for the contained anchor element
         */
        "anchorTabIndex"?: string;
        /**
          * Title for the contained anchor element
         */
        "anchorTitle"?: string;
        /**
          * If the link is disabled. Prevents the user from interacting with the link: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * Link is for an external site
         */
        "external"?: boolean;
        /**
          * If the button should navigate within the router context, or force a refresh.
         */
        "forceRefresh"?: boolean;
        /**
          * Target for link (eg: target="_blank")
         */
        "target"?: string;
        /**
          * Where the button should link to.
         */
        "url"?: string;
        /**
          * Which styling variant to use
         */
        "variant"?: ButtonVariant;
    }
    /**
     * Calls out a piece of information.
     */
    interface EsCallout {
        /**
          * Heading text.
         */
        "heading": string;
        /**
          * Override the variant icon.
         */
        "icon"?: IconDescription;
        /**
          * Which color set to use.
         */
        "variant"?: EsCalloutVariant;
    }
    /**
     * Copies the text passed as a child when clicked.
     */
    interface EsCopy {
    }
    /**
     * Display a banner with text in the corner.
     */
    interface EsCornerBanner {
        /**
          * Which styling variant to use.
         */
        "variant"?: CornerBannerVariant;
        /**
          * X location of the banner.
         */
        "x"?: 'left' | 'right';
        /**
          * Y location of the banner
         */
        "y"?: 'top' | 'bottom';
    }
    /**
     * A pill display of an number, that pulses on change. Caps out at 999.
     */
    interface EsCounter {
        /**
          * Choose the color variant of the counter
         */
        "color"?: CounterColor;
        /**
          * The number to display
         */
        "count"?: number;
        /**
          * The height of the counter that the rest of the dimensions scale from
         */
        "size"?: number;
        /**
          * The display style of the counter.
         */
        "variant"?: CounterVariant;
    }
    /**
     * Displays an icon loaded from the `iconStore`. An icon named "spinner" will automatically spin.
     * See [IconStore](/components/variables/iconStore) for details on how to load icons.
     */
    interface EsIcon {
        /**
          * Rotate the icon to a speciied angle.
         */
        "angle"?: number;
        /**
          * Which icon to display.
         */
        "icon": IconDescription;
        /**
          * The hight and width to scale the icon to.
         */
        "size"?: number;
        /**
          * Apply a spin animation.
         */
        "spin"?: boolean;
        /**
          * When spinning, should it spin clockwise or anticlockwise.
         */
        "spinDirection"?: 'clockwise' | 'antiClockwise';
    }
    /**
     * Display a row of five pulsing dots, to indicate loading.
     */
    interface EsLoadingDots {
    }
    /**
     * Displays a grey block to placehold loading text.
     */
    interface EsLoadingText {
        /**
          * The expected loaded text length.
         */
        "expectedLength": number;
        /**
          * Adds a random number of chars (up to the passed amount)
         */
        "variance"?: number;
    }
    /**
     * A pop up modal for overlaying information, warnings and confirmations.
     * Traps focus within the modal, and returns focus to previous location when closed.
     * Pair with an [`es-portal`](/components/components/es-portal) to open and close.
     */
    interface EsModal {
        /**
          * If the modal should have a footer.
         */
        "footer"?: boolean;
        /**
          * If the modal should have a header.
         */
        "header"?: boolean;
        /**
          * Triggers when the modal requests to be closed.
         */
        "onRequestClose"?: (event: EsModalCustomEvent<void>) => void;
    }
    /**
     * Page navigation with ability to jump to first and last pages with `pageCount` is provided.
     */
    interface EsPagination {
        /**
          * Current Page.
         */
        "current": number;
        /**
          * Triggered when a pagination button is clicked
         */
        "onUpdate"?: (event: EsPaginationCustomEvent<PageChangeEventType>) => void;
        /**
          * Number of pages.
         */
        "pageCount"?: number;
    }
    /**
     * Attaches a portaled popover, attached to the parent node. Can be used to create dropdowns, tooltips etc. The parent scoped shadow styles are copied to the created portals shadow styles, to allow styling popover contents externally.
     */
    interface EsPopover {
        /**
          * If the popover should render an arrow.
         */
        "arrow"?: boolean;
        /**
          * Pass an element to attach the popover to. (Defaults to the parent element.)
         */
        "attachTo"?: HTMLElement;
        /**
          * Constrain the size of the popover to the size of the attachment node.
         */
        "autoSize"?: Constrain;
        /**
          * If the popover should overlay a backdrop, to prevent external clicks.
         */
        "backdrop"?: boolean;
        /**
          * If the popover should request to close when focus is lost
         */
        "closeOnBlur"?: boolean;
        /**
          * If the popover should request to close when clicked outside
         */
        "closeOnClickOutside"?: boolean;
        /**
          * If the popover should request to close when esc is pressed
         */
        "closeOnEsc"?: boolean;
        /**
          * If the popover should request to close when the attachment element scrolls out of view
         */
        "closeOnScrollEscape"?: boolean;
        /**
          * Constrain the size of the popover inner to the size of the window.
         */
        "constrain"?: Constrain;
        /**
          * An array of allowed placements or enable / disable
         */
        "flip"?: Placement[] | boolean;
        /**
          * If the popover should hide itself when the attachment element scrolls out of view
         */
        "hideOnScrollEscape"?: boolean;
        /**
          * The maximum height to constrain to.
         */
        "maxHeight"?: number;
        /**
          * The maximum width to constrain to.
         */
        "maxWidth"?: number;
        /**
          * The offset away from the attachement element in px.
         */
        "offset"?: number;
        /**
          * Triggers when the popover requests to close.
         */
        "onRequestClose"?: (event: EsPopoverCustomEvent<any>) => void;
        /**
          * Toggles if the popover is open or not.
         */
        "open"?: boolean;
        /**
          * Where to place the popover in relation to the attachment point.
         */
        "placement"?: Placement;
        /**
          * Class name for the popper
         */
        "popperClass"?: string;
        /**
          * A query selecter to select the element to portal the popper to.
         */
        "target"?: string;
        /**
          * If the popover should trap focus within, and return focus on close.
         */
        "trapFocus"?: boolean;
        /**
          * What zIndex to place the popover in.
         */
        "zIndex"?: number;
    }
    interface EsPopper {
        "backdrop"?: boolean;
        "onRequestClose"?: (event: EsPopperCustomEvent<any>) => void;
        "trapFocus"?: boolean;
    }
    interface EsPopperInner {
    }
    interface EsPopperX {
    }
    interface EsPopperY {
    }
    /**
     * Portals the passed node to a different part of the document. Note that portal does not transfer shadow scoped styles, unlike `es-popover`, so any portaled elements should be self contained.
     */
    interface EsPortal {
        /**
          * If the portal should overlay a backdrop, to prevent external clicks.
         */
        "backdrop"?: boolean;
        /**
          * Triggers when the popover requests to close.
         */
        "onRequestClose"?: (event: EsPortalCustomEvent<any>) => void;
        /**
          * If the element is portaled or not.
         */
        "open"?: boolean;
        /**
          * If the portal should prevent overscroll
         */
        "preventOverscroll"?: boolean;
        /**
          * The element to render.
         */
        "renderElement": RenderFunction;
        /**
          * A query selector to select the location to portal to.
         */
        "target"?: string;
    }
    /**
     * A wizard progression bar.
     */
    interface EsProgression {
        /**
          * A list of checkpoints to display.
         */
        "checkpoints": Checkpoint[];
        /**
          * Set custom colors for all checkpoints
         */
        "colors"?: Partial<Record<CheckpointState, string>>;
        /**
          * Set custom icons for all checkpoints
         */
        "icons"?: Partial<Record<CheckpointState, IconDescription>>;
        /**
          * The current active location.
         */
        "location": string;
        /**
          * Emitted when a checkpoint is clicked.
         */
        "onProgressionRequest"?: (event: EsProgressionCustomEvent<string>) => void;
        /**
          * Disable interactivity.
         */
        "readonly"?: boolean;
    }
    /**
     * Wraps a [ResizeObserver](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver) to allow tracking `DOMRect` dimensions
     */
    interface EsResizeObserver {
        /**
          * Triggered when the size of the element changes.
         */
        "onSizeChanged"?: (event: EsResizeObserverCustomEvent<DOMRectReadOnly>) => void;
    }
    interface EsStatus {
        "status": Status;
    }
    /**
     * Create a table from data.
     */
    interface EsTable {
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any, any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: string[];
        /**
          * Pass extra props to cells
         */
        "extraCellProps"?: (key: string, data: any) => Record<string, any>;
        /**
          * Sync function for extracting the data from the row. By default, it assumes you passed an array of data as your columns.
         */
        "getCellData"?: (key: string) => any;
        /**
          * Do not render header.
         */
        "headless"?: boolean;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier"?: string;
        /**
          * A function to calculate a href from the cell data.
         */
        "linkRowTo"?: (row: any) => string;
        /**
          * Triggered whenever a row is clicked.
         */
        "onClickRow"?: (event: EsTableCustomEvent<ClickRow<any>>) => void;
        /**
          * Triggered whenever a sortable header is clicked
         */
        "onClickSort"?: (event: EsTableCustomEvent<string>) => void;
        /**
          * Allows rendering a node after the row.
         */
        "renderExpansion"?: RenderFunction<[key: string]>;
        /**
          * A function to calculate the class or classes of the row from the cellData.
         */
        "rowClass"?: (
        row: any,
        key: string,
    ) => Record<string, boolean> | string | undefined;
        /**
          * If rows should be allowed to take focus
         */
        "rowTakesFocus"?: boolean;
        /**
          * An array of rows to render. Each item in the array is passed to getCellData, to allow passing keys or other identifiers.
         */
        "rows": any[];
        /**
          * How the table is sorted
         */
        "sort"?: TableSort;
        /**
          * Header sticks to scroll parent.
         */
        "stickyHeader"?: boolean;
    }
    /**
     * Render a single row data as a grid of information.
     */
    interface EsTableDetail {
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any, any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: Array<string>;
        /**
          * The data to render.
         */
        "data": any;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier"?: string;
    }
    /**
     * A default header for [`es-table-detail`](/components/components/es-table-detail).
     */
    interface EsTableDetailHeader {
        /**
          * Which cell to place in the top right as a list of actions.
         */
        "actionsCell"?: string;
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any, any>;
        /**
          * The data to render.
         */
        "data": any;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier"?: string;
        /**
          * Which cell to place as the title
         */
        "titleCell"?: string;
    }
    /**
     * Create a nested table from data.
     */
    interface EsTableNested {
        /**
          * A path to a the currently active row, to auto expand its parent and show it as selected.
         */
        "activePath"?: string[];
        /**
          * Function to decide if a row can take expand, to show a nested table.
         */
        "canExpand"?: (key: string, data: any, depth: number) => boolean;
        /**
          * Function to decide if a row can expand more, to show more rows in the nested table.
         */
        "canExpandMore"?: (key: string, count: number) => boolean;
        /**
          * A record of table cell definitions.Some built in cells are cells are available for use: - `--borderless`: A blank placeholder cell with no border, for aligning with the parent cell. - `--no-pad`: A blank placeholder cell, for aligning with the parent cell. - `--expander`: The expander button.
         */
        "cells": TableCells<any, any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: string[];
        /**
          * Number of rows to be expanded by default
         */
        "defaultExpanded"?: (key: string, depth: number) => number;
        /**
          * Number number of rows to display in expansion
         */
        "expandBy"?: number;
        /**
          * Pass extra props to cells
         */
        "extraCellProps"?: (key: string, data: any) => Record<string, any>;
        /**
          * Sync function for extracting the data from the row. By default, it assumes you passed an array of data as your columns.
         */
        "getCellData"?: (key: string) => any;
        /**
          * Sync function for extracting the data from the nested row. By default, it assumes you passed an array of data as your columns.
         */
        "getNestedCellData"?: (key: string) => any;
        /**
          * Sync function for extracting a list of rows for the nested table
         */
        "getNestedRows"?: (key: string, count: number) => any[] | undefined;
        /**
          * Do not render header.
         */
        "headless"?: boolean;
        /**
          * A function to calculate a href from the cell data.
         */
        "linkRowTo"?: (row: any) => string;
        /**
          * async function for loading nested data when a row is expanded.
         */
        "loadNested"?: (key: string, data: any) => Promise<void>;
        /**
          * The order and keys of the cells to be rendered in a nested table. If omitted, all cells will be rendered.
         */
        "nestedColumns"?: string[];
        /**
          * Passed to cell renderer as `parent`.
         */
        "nestedIdentifier"?: string;
        /**
          * If the nested rows should be allowed to take focus.
         */
        "nestedRowTakesFocus"?: boolean;
        /**
          * Triggered whenever a row (or nested row) is clicked. The `detail` is the item in the row array.
         */
        "onClickRow"?: (event: EsTableNestedCustomEvent<any>) => void;
        /**
          * Triggered whenever a row is expanded.
         */
        "onExpansion"?: (event: EsTableNestedCustomEvent<{ data: any; key: string }>) => void;
        /**
          * Passed to cell renderer as `parent`.
         */
        "outerIdentifier"?: string;
        /**
          * A function to calculate the class or classes of the row from the cellData.
         */
        "rowClass"?: (
        row: any,
        key: string,
    ) => Record<string, boolean> | string | undefined;
        /**
          * If rows should be allowed to take focus
         */
        "rowTakesFocus"?: boolean;
        /**
          * An array of rows to render. Each item in the array is passed to getCellData, to allow passing keys or other identifiers.
         */
        "rows": any[];
        /**
          * Header sticks to scroll parent.
         */
        "stickyHeader"?: boolean;
        /**
          * If clicking a row should expand it.
         */
        "toggleRowOnClick"?: boolean;
    }
    /**
     * Create a virtualized table from data.
     */
    interface EsTableVirtualized {
        /**
          * The height (in pixels) of the after
         */
        "afterHeight"?: number;
        /**
          * The height (in pixels) of the before
         */
        "beforeHeight"?: number;
        /**
          * Groups rows into blocks
         */
        "blockSize"?: number;
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any, any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: string[];
        /**
          * Pass extra props to cells
         */
        "extraCellProps"?: (key: string, data: any) => Record<string, any>;
        /**
          * Sync function for extracting the data from the row. By default, it assumes you passed an array of data as your columns.
         */
        "getCellData": (key: string, index: number) => any;
        /**
          * Sync function for converting an index into a key
         */
        "getKeyFromIndex"?: (index: number) => string;
        /**
          * The height (in pixels) of the header
         */
        "headerHeight"?: number;
        /**
          * Do not render header.
         */
        "headless"?: boolean;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier"?: string;
        /**
          * A function to calculate a href from the cell data.
         */
        "linkRowTo"?: (row: any) => string;
        /**
          * Triggered whenever a row is clicked. The `detail` is the item in the row array.
         */
        "onClickRow"?: (event: EsTableVirtualizedCustomEvent<ClickRow>) => void;
        /**
          * Triggered whenever a sortable header is clicked
         */
        "onClickSort"?: (event: EsTableVirtualizedCustomEvent<string>) => void;
        /**
          * Triggered when the first block is rendered
         */
        "onFirstBlock"?: (event: EsTableVirtualizedCustomEvent<void>) => void;
        /**
          * Triggered when the last block is rendered
         */
        "onLastBlock"?: (event: EsTableVirtualizedCustomEvent<void>) => void;
        /**
          * Triggered when a block is rendered
         */
        "onLoadBlock"?: (event: EsTableVirtualizedCustomEvent<LoadWindow>) => void;
        /**
          * The size of the grid rows before starting a reflow
         */
        "reflowSize"?: number;
        /**
          * Display in a row after the last row
         */
        "renderAfter"?: RenderFunction;
        /**
          * Display in a row before the first row
         */
        "renderBefore"?: RenderFunction;
        /**
          * A function to calculate the class or classes of the row from the cellData.
         */
        "rowClass"?: (
        row: any,
        key: string,
        index: number,
    ) => Record<string, boolean> | string | undefined;
        /**
          * The total number of rows
         */
        "rowCount": number;
        /**
          * The height (in pixels) of the row
         */
        "rowHeight"?: number;
        /**
          * If rows should be allowed to take focus
         */
        "rowTakesFocus"?: boolean;
        /**
          * If the table should lock scroll on appending events
         */
        "scrollLock"?: boolean;
        /**
          * How the table is sorted
         */
        "sort"?: TableSort;
        /**
          * Header sticks to scroll parent.
         */
        "stickyHeader"?: boolean;
        /**
          * The size of the window to render
         */
        "windowSize"?: number;
    }
    /**
     * A tabbed panel. Each panel can be targeted via a slot.
     */
    interface EsTabs {
        /**
          * The currently active panel. By default it will take from the passed activeParam, or the first tab.
         */
        "active"?: string;
        /**
          * Reflect the active tab to a search param of name. Set to false to disable.
         */
        "activeParam"?: string | false;
        /**
          * Icon to be rendered between each tab.
         */
        "interTabIcon"?: IconDescription;
        /**
          * thu size of the icon to be rendered between each tab.
         */
        "interTabIconSize"?: number;
        /**
          * Triggered when the active tab is changed. `detail` is the newly active tab.
         */
        "onTabChange"?: (event: EsTabsCustomEvent<string>) => void;
        /**
          * A list of tabs.
         */
        "tabs": Tab[];
    }
    /**
     * A button with an icon that displays the state of a async action on click.
     */
    interface EsThinkingButton {
        /**
          * The async action to be called on click.
         */
        "action": (e: MouseEvent) => Promise<unknown>;
        /**
          * The icon to display when the action completed successfully.
         */
        "completeIcon"?: IconDescription;
        /**
          * The default icon to display when nothing is happening.
         */
        "defaultIcon": IconDescription;
        /**
          * If the button is disabled. Prevents the user from interacting with the button: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * The icon to display when the action errored out.
         */
        "failedIcon"?: IconDescription;
        /**
          * Optional text of the button
         */
        "text"?: string;
        /**
          * The icon to display when we are awaiting the action.
         */
        "thinkingIcon"?: IconDescription;
        /**
          * Which styling variant to use.
         */
        "variant"?: HTMLEsButtonElement['variant'];
    }
    interface EsToast {
        "count": Toast['count'];
        "icon": Toast['icon'];
        "level": ToastLevel;
    }
    interface EsToaster {
    }
    /**
     * A multi step wizard. Each step can be targeted via a slot.
     */
    interface EsWizard {
        /**
          * The currently active page
         */
        "location": string;
        /**
          * A list of pages describing each step.
         */
        "pages": WizardPage[];
        /**
          * Offset the scroll to top on page change
         */
        "scrollOffset"?: number;
    }
    interface IntrinsicElements {
        "es-accordian": EsAccordian;
        "es-backdrop": EsBackdrop;
        "es-badge": EsBadge;
        "es-button": EsButton;
        "es-button-link": EsButtonLink;
        "es-callout": EsCallout;
        "es-copy": EsCopy;
        "es-corner-banner": EsCornerBanner;
        "es-counter": EsCounter;
        "es-icon": EsIcon;
        "es-loading-dots": EsLoadingDots;
        "es-loading-text": EsLoadingText;
        "es-modal": EsModal;
        "es-pagination": EsPagination;
        "es-popover": EsPopover;
        "es-popper": EsPopper;
        "es-popper-inner": EsPopperInner;
        "es-popper-x": EsPopperX;
        "es-popper-y": EsPopperY;
        "es-portal": EsPortal;
        "es-progression": EsProgression;
        "es-resize-observer": EsResizeObserver;
        "es-status": EsStatus;
        "es-table": EsTable;
        "es-table-detail": EsTableDetail;
        "es-table-detail-header": EsTableDetailHeader;
        "es-table-nested": EsTableNested;
        "es-table-virtualized": EsTableVirtualized;
        "es-tabs": EsTabs;
        "es-thinking-button": EsThinkingButton;
        "es-toast": EsToast;
        "es-toaster": EsToaster;
        "es-wizard": EsWizard;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * Optionally collapsible sectioned view. Each section can be targeted via a part.
             */
            "es-accordian": LocalJSX.EsAccordian & JSXBase.HTMLAttributes<HTMLEsAccordianElement>;
            "es-backdrop": LocalJSX.EsBackdrop & JSXBase.HTMLAttributes<HTMLEsBackdropElement>;
            /**
             * Display a counter or dot beside a component to indicate action being required.
             */
            "es-badge": LocalJSX.EsBadge & JSXBase.HTMLAttributes<HTMLEsBadgeElement>;
            /**
             * A button.
             */
            "es-button": LocalJSX.EsButton & JSXBase.HTMLAttributes<HTMLEsButtonElement>;
            /**
             * Anchor link version of es-button, wraps a `Link` from `@eventstore-ui/router`.
             */
            "es-button-link": LocalJSX.EsButtonLink & JSXBase.HTMLAttributes<HTMLEsButtonLinkElement>;
            /**
             * Calls out a piece of information.
             */
            "es-callout": LocalJSX.EsCallout & JSXBase.HTMLAttributes<HTMLEsCalloutElement>;
            /**
             * Copies the text passed as a child when clicked.
             */
            "es-copy": LocalJSX.EsCopy & JSXBase.HTMLAttributes<HTMLEsCopyElement>;
            /**
             * Display a banner with text in the corner.
             */
            "es-corner-banner": LocalJSX.EsCornerBanner & JSXBase.HTMLAttributes<HTMLEsCornerBannerElement>;
            /**
             * A pill display of an number, that pulses on change. Caps out at 999.
             */
            "es-counter": LocalJSX.EsCounter & JSXBase.HTMLAttributes<HTMLEsCounterElement>;
            /**
             * Displays an icon loaded from the `iconStore`. An icon named "spinner" will automatically spin.
             * See [IconStore](/components/variables/iconStore) for details on how to load icons.
             */
            "es-icon": LocalJSX.EsIcon & JSXBase.HTMLAttributes<HTMLEsIconElement>;
            /**
             * Display a row of five pulsing dots, to indicate loading.
             */
            "es-loading-dots": LocalJSX.EsLoadingDots & JSXBase.HTMLAttributes<HTMLEsLoadingDotsElement>;
            /**
             * Displays a grey block to placehold loading text.
             */
            "es-loading-text": LocalJSX.EsLoadingText & JSXBase.HTMLAttributes<HTMLEsLoadingTextElement>;
            /**
             * A pop up modal for overlaying information, warnings and confirmations.
             * Traps focus within the modal, and returns focus to previous location when closed.
             * Pair with an [`es-portal`](/components/components/es-portal) to open and close.
             */
            "es-modal": LocalJSX.EsModal & JSXBase.HTMLAttributes<HTMLEsModalElement>;
            /**
             * Page navigation with ability to jump to first and last pages with `pageCount` is provided.
             */
            "es-pagination": LocalJSX.EsPagination & JSXBase.HTMLAttributes<HTMLEsPaginationElement>;
            /**
             * Attaches a portaled popover, attached to the parent node. Can be used to create dropdowns, tooltips etc. The parent scoped shadow styles are copied to the created portals shadow styles, to allow styling popover contents externally.
             */
            "es-popover": LocalJSX.EsPopover & JSXBase.HTMLAttributes<HTMLEsPopoverElement>;
            "es-popper": LocalJSX.EsPopper & JSXBase.HTMLAttributes<HTMLEsPopperElement>;
            "es-popper-inner": LocalJSX.EsPopperInner & JSXBase.HTMLAttributes<HTMLEsPopperInnerElement>;
            "es-popper-x": LocalJSX.EsPopperX & JSXBase.HTMLAttributes<HTMLEsPopperXElement>;
            "es-popper-y": LocalJSX.EsPopperY & JSXBase.HTMLAttributes<HTMLEsPopperYElement>;
            /**
             * Portals the passed node to a different part of the document. Note that portal does not transfer shadow scoped styles, unlike `es-popover`, so any portaled elements should be self contained.
             */
            "es-portal": LocalJSX.EsPortal & JSXBase.HTMLAttributes<HTMLEsPortalElement>;
            /**
             * A wizard progression bar.
             */
            "es-progression": LocalJSX.EsProgression & JSXBase.HTMLAttributes<HTMLEsProgressionElement>;
            /**
             * Wraps a [ResizeObserver](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver) to allow tracking `DOMRect` dimensions
             */
            "es-resize-observer": LocalJSX.EsResizeObserver & JSXBase.HTMLAttributes<HTMLEsResizeObserverElement>;
            "es-status": LocalJSX.EsStatus & JSXBase.HTMLAttributes<HTMLEsStatusElement>;
            /**
             * Create a table from data.
             */
            "es-table": LocalJSX.EsTable & JSXBase.HTMLAttributes<HTMLEsTableElement>;
            /**
             * Render a single row data as a grid of information.
             */
            "es-table-detail": LocalJSX.EsTableDetail & JSXBase.HTMLAttributes<HTMLEsTableDetailElement>;
            /**
             * A default header for [`es-table-detail`](/components/components/es-table-detail).
             */
            "es-table-detail-header": LocalJSX.EsTableDetailHeader & JSXBase.HTMLAttributes<HTMLEsTableDetailHeaderElement>;
            /**
             * Create a nested table from data.
             */
            "es-table-nested": LocalJSX.EsTableNested & JSXBase.HTMLAttributes<HTMLEsTableNestedElement>;
            /**
             * Create a virtualized table from data.
             */
            "es-table-virtualized": LocalJSX.EsTableVirtualized & JSXBase.HTMLAttributes<HTMLEsTableVirtualizedElement>;
            /**
             * A tabbed panel. Each panel can be targeted via a slot.
             */
            "es-tabs": LocalJSX.EsTabs & JSXBase.HTMLAttributes<HTMLEsTabsElement>;
            /**
             * A button with an icon that displays the state of a async action on click.
             */
            "es-thinking-button": LocalJSX.EsThinkingButton & JSXBase.HTMLAttributes<HTMLEsThinkingButtonElement>;
            "es-toast": LocalJSX.EsToast & JSXBase.HTMLAttributes<HTMLEsToastElement>;
            "es-toaster": LocalJSX.EsToaster & JSXBase.HTMLAttributes<HTMLEsToasterElement>;
            /**
             * A multi step wizard. Each step can be targeted via a slot.
             */
            "es-wizard": LocalJSX.EsWizard & JSXBase.HTMLAttributes<HTMLEsWizardElement>;
        }
    }
}
