/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { AccordianSection } from "./components/es-accordian/types";
import { VNode } from "@stencil/core";
import { BadgeVariant } from "./components/es-badge/es-badge";
import { ButtonVariant } from "./components/buttons/types";
import { EsCalloutVariant } from "./components/es-callout/es-callout";
import { IconDescription } from "./components/es-icon/types";
import { CornerBannerVariant } from "./components/es-corner-banner/es-corner-banner";
import { CounterColor, CounterVariant } from "./components/es-counter/es-counter";
import { PageChangeEventType } from "./components/es-pagination/types";
import { Constrain } from "./components/es-popover/es-popover";
import { Placement } from "@floating-ui/dom";
import { Checkpoint } from "./components/es-progression/es-progression";
import { Status } from "./components/es-status/es-status";
import { TableCells } from "./components/es-table/types";
import { Tab } from "./components/es-tabs/types";
import { Toast, ToastLevel, ToastOptions } from "./components/toast/types";
import { WizardPage } from "./components/es-wizard/types";
export namespace Components {
    interface EsAccordian {
        /**
          * An array of sections to display.
         */
        "sections": AccordianSection[];
        /**
          * Display numbered counters beside each title.
         */
        "steps": boolean;
    }
    interface EsBackdrop {
        "close": () => Promise<void>;
        "renderNode": (node: VNode | null) => Promise<void>;
        "showBackdrop": boolean;
    }
    interface EsBadge {
        /**
          * Choose the color variant of the badge
         */
        "color": HTMLEsCounterElement['color'];
        /**
          * What number to display in the counter (or if the dot should display)
         */
        "count": number;
        /**
          * Show the dot and counter even if the count 0 (or negative)
         */
        "showZero": boolean;
        /**
          * The base size (in px) of the counter (has no effect on the dot)
         */
        "size"?: number;
        /**
          * Select the display variant of the badge
         */
        "variant": BadgeVariant;
    }
    interface EsButton {
        /**
          * If the button is disabled. Prevents the user from interacting with the button: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * The default behavior of the button.
         */
        "type": string;
        /**
          * Which styling variant to use.
         */
        "variant": ButtonVariant;
    }
    interface EsButtonLink {
        /**
          * Class for the contained anchor element
         */
        "anchorClass"?: string;
        /**
          * Id for the contained anchor element
         */
        "anchorId"?: string;
        /**
          * Role for the contained anchor element
         */
        "anchorRole"?: string;
        /**
          * Tab Index for the contained anchor element
         */
        "anchorTabIndex"?: string;
        /**
          * Title for the contained anchor element
         */
        "anchorTitle"?: string;
        /**
          * If the link is disabled. Prevents the user from interacting with the link: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * Link is for an external site
         */
        "external"?: boolean;
        /**
          * If the button should navigate within the router context, or force a refresh.
         */
        "forceRefresh"?: boolean;
        /**
          * Target for link (eg: target="_blank")
         */
        "target"?: string;
        /**
          * Where the button should link to.
         */
        "url"?: string;
        /**
          * Which styling variant to use
         */
        "variant": ButtonVariant;
    }
    interface EsCallout {
        /**
          * Heading text.
         */
        "heading": string;
        /**
          * Override the variant icon.
         */
        "icon"?: IconDescription;
        /**
          * Which color set to use.
         */
        "variant": EsCalloutVariant;
    }
    interface EsCopy {
        /**
          * Manually triggers the copy of the inner text.
         */
        "copy": () => Promise<void>;
    }
    interface EsCornerBanner {
        /**
          * Which styling variant to use.
         */
        "variant": CornerBannerVariant;
        /**
          * X location of the banner.
         */
        "x": 'left' | 'right';
        /**
          * Y location of the banner
         */
        "y": 'top' | 'bottom';
    }
    interface EsCounter {
        /**
          * Choose the color variant of the counter
         */
        "color"?: CounterColor;
        /**
          * The number to display
         */
        "count": number;
        /**
          * The height of the counter that the rest of the dimensions scale from
         */
        "size": number;
        /**
          * The display style of the counter.
         */
        "variant": CounterVariant;
    }
    interface EsIcon {
        /**
          * Rotate the icon to a speciied angle.
         */
        "angle": number;
        /**
          * Which icon to display.
         */
        "icon": IconDescription;
        /**
          * The hight and width to scale the icon to.
         */
        "size": number;
        /**
          * Apply a spin animation.
         */
        "spin"?: boolean;
        /**
          * When spinning, should it spin clockwise or anticlockwise.
         */
        "spinDirection": 'clockwise' | 'antiClockwise';
        /**
          * Provides a promise that resolves at the end of a single spin, if the icon is spinning.
         */
        "spinEnd": () => Promise<void>;
    }
    interface EsModal {
        /**
          * If the modal should have a footer.
         */
        "footer": boolean;
        /**
          * If the modal should have a header.
         */
        "header": boolean;
    }
    interface EsPagination {
        /**
          * Current Page.
         */
        "current": number;
        /**
          * Number of pages.
         */
        "pageCount"?: number;
    }
    interface EsPopover {
        /**
          * If the popover should render an arrow.
         */
        "arrow": boolean;
        /**
          * Pass an element to attach the popover to. (Defaults to the parent element.)
         */
        "attachTo"?: HTMLElement;
        /**
          * Constrain the size of the popover to the size of the attachment node.
         */
        "autoSize": Constrain;
        /**
          * If the popover should overlay a backdrop, to prevent external clicks.
         */
        "backdrop": boolean;
        /**
          * If the popover should request to close when focus is lost
         */
        "closeOnBlur": boolean;
        /**
          * Constrain the size of the popover inner to the size of the window.
         */
        "constrain": Constrain;
        /**
          * An array of allowed placements or enable / disable
         */
        "flip"?: Placement[] | boolean;
        /**
          * The maximum height to constrain to.
         */
        "maxHeight": number;
        /**
          * The maximum width to constrain to.
         */
        "maxWidth": number;
        /**
          * The offset away from the attachement element in px.
         */
        "offset": number;
        /**
          * Toggles if the popover is open or not.
         */
        "open": boolean;
        /**
          * Where to place the popover in relation to the attachment point.
         */
        "placement": Placement;
        /**
          * Class name for the popper
         */
        "popperClass"?: string;
        /**
          * A query selecter to select the element to portal the popper to.
         */
        "target": string;
        /**
          * If the popover should trap focus within, and return focus on close.
         */
        "trapFocus": boolean;
        /**
          * What zIndex to place the popover in.
         */
        "zIndex"?: number;
    }
    interface EsPopper {
        "backdrop": boolean;
        "loaded": () => Promise<boolean>;
        "trapFocus": boolean;
    }
    interface EsPopperInner {
    }
    interface EsPortal {
        "attachElement": () => Promise<void>;
        /**
          * If the portal should overlay a backdrop, to prevent external clicks.
         */
        "backdrop": boolean;
        "detatchElement": () => Promise<void>;
        /**
          * The element to render.
         */
        "element": VNode;
        /**
          * If the element is portaled or not.
         */
        "open": boolean;
        /**
          * A query selector to select the location to portal to.
         */
        "target": string;
    }
    interface EsProgression {
        /**
          * A list of checkpoints to display.
         */
        "checkpoints": Checkpoint[];
        /**
          * The current active location.
         */
        "location": string;
    }
    interface EsResizeObserver {
    }
    interface EsStatus {
        "status": Status;
    }
    interface EsTable {
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: string[];
        /**
          * Sync function for extracting the data from the row. By default, it assumes you passed an array of data as your columns.
         */
        "getCellData": (key: string) => any;
        /**
          * Do not render header.
         */
        "headless": boolean;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier": string;
        /**
          * A function to calculate a href from the cell data.
         */
        "linkRowTo"?: (row: any) => string;
        /**
          * Allows rendering a node after the row.
         */
        "renderExpansion": (key: string) => VNode | null;
        /**
          * A function to calculate the class or classes of the row from the cellData.
         */
        "rowClass": (
        row: any,
    ) => Record<string, boolean> | string | undefined;
        /**
          * If rows should be allowed to take focus
         */
        "rowTakesFocus"?: boolean;
        /**
          * An array of rows to render. Each item in the array is passed to getCellData, to allow passing keys or other identifiers.
         */
        "rows": any[];
    }
    interface EsTableDetail {
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: Array<string>;
        /**
          * The data to render.
         */
        "data": any;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier": string;
    }
    interface EsTableDetailHeader {
        /**
          * Which cell to place in the top right as a list of actions.
         */
        "actionsCell": string;
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any>;
        /**
          * The data to render.
         */
        "data": any;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier": string;
        /**
          * Which cell to place as the title
         */
        "titleCell": string;
    }
    interface EsTableNested {
        /**
          * A path to a the currently active row, to auto expand its parent and show it as selected.
         */
        "activePath"?: string[];
        /**
          * Function to decide if a row can take expand, to show a nested table.
         */
        "canExpand": (key: string, data: any) => boolean;
        /**
          * Function to decide if a row can expand more, to show more rows in the nested table.
         */
        "canExpandMore": (key: string, count: number) => boolean;
        /**
          * A record of table cell definitions.Some built in cells are cells are available for use: - `--borderless`: A blank placeholder cell with no border, for aligning with the parent cell. - `--no-pad`: A blank placeholder cell, for aligning with the parent cell. - `expander`: The expander button.
         */
        "cells": TableCells<any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: string[];
        /**
          * Number number of rows to display in expansion
         */
        "expandBy": number;
        /**
          * Sync function for extracting the data from the row. By default, it assumes you passed an array of data as your columns.
         */
        "getCellData"?: (key: string) => any;
        /**
          * Sync function for extracting the data from the nested row. By default, it assumes you passed an array of data as your columns.
         */
        "getNestedCellData"?: (key: string) => any;
        /**
          * Sync function for extracting a list of rows for the nested table
         */
        "getNestedRows"?: (key: string, count: number) => any[] | undefined;
        /**
          * A function to calculate a href from the cell data.
         */
        "linkRowTo"?: (row: any) => string;
        /**
          * async function for loading nested data when a row is expanded.
         */
        "loadNested"?: (key: string, data: any) => Promise<void>;
        /**
          * The order and keys of the cells to be rendered in a nested table. If omitted, all cells will be rendered.
         */
        "nestedColumns"?: string[];
        /**
          * Passed to cell renderer as `parent`.
         */
        "nestedIdentifier": string;
        /**
          * If the nested rows should be allowed to take focus.
         */
        "nestedRowTakesFocus"?: boolean;
        /**
          * Passed to cell renderer as `parent`.
         */
        "outerIdentifier": string;
        /**
          * A function to calculate the class or classes of the row from the cellData.
         */
        "rowClass": (
        row: any,
    ) => Record<string, boolean> | string | undefined;
        /**
          * If rows should be allowed to take focus
         */
        "rowTakesFocus"?: boolean;
        /**
          * An array of rows to render. Each item in the array is passed to getCellData, to allow passing keys or other identifiers.
         */
        "rows": any[];
    }
    interface EsTabs {
        /**
          * The currently active panel. By default it will take from the passed activeParam, or the first tab.
         */
        "active"?: string;
        /**
          * Reflect the active tab to a search param of name. Set to false to disable.
         */
        "activeParam": string | false;
        /**
          * A list of tabs.
         */
        "tabs": Tab[];
    }
    interface EsThinkingButton {
        /**
          * The async action to be called on click.
         */
        "action": (e: MouseEvent) => Promise<unknown>;
        /**
          * The icon to display when the action completed successfully.
         */
        "completeIcon": IconDescription;
        /**
          * The default icon to display when nothing is happening.
         */
        "defaultIcon": IconDescription;
        /**
          * If the button is disabled. Prevents the user from interacting with the button: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * The icon to display when the action errored out.
         */
        "failedIcon": IconDescription;
        /**
          * Optional text of the button
         */
        "text"?: string;
        /**
          * The icon to display when we are awaiting the action.
         */
        "thinkingIcon": IconDescription;
        /**
          * Which styling variant to use.
         */
        "variant": HTMLEsButtonElement['variant'];
    }
    interface EsToast {
        "close": () => Promise<void>;
        "count": Toast['count'];
        "icon": Toast['icon'];
        "level": ToastLevel;
    }
    interface EsToaster {
        "popToast": (level: ToastLevel | undefined, { message, title, duration, icon, onClick, }: ToastOptions) => Promise<() => void>;
    }
    interface EsWizard {
        /**
          * The currently active page
         */
        "location": string;
        /**
          * A list of pages describing each step.
         */
        "pages": WizardPage[];
        /**
          * Offset the scroll to top on page change
         */
        "scrollOffset": number;
    }
}
export interface EsBackdropCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsBackdropElement;
}
export interface EsModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsModalElement;
}
export interface EsPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsPaginationElement;
}
export interface EsPopoverCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsPopoverElement;
}
export interface EsPopperCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsPopperElement;
}
export interface EsPortalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsPortalElement;
}
export interface EsProgressionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsProgressionElement;
}
export interface EsResizeObserverCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsResizeObserverElement;
}
export interface EsTableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsTableElement;
}
export interface EsTableNestedCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsTableNestedElement;
}
export interface EsTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLEsTabsElement;
}
declare global {
    interface HTMLEsAccordianElement extends Components.EsAccordian, HTMLStencilElement {
    }
    var HTMLEsAccordianElement: {
        prototype: HTMLEsAccordianElement;
        new (): HTMLEsAccordianElement;
    };
    interface HTMLEsBackdropElement extends Components.EsBackdrop, HTMLStencilElement {
    }
    var HTMLEsBackdropElement: {
        prototype: HTMLEsBackdropElement;
        new (): HTMLEsBackdropElement;
    };
    interface HTMLEsBadgeElement extends Components.EsBadge, HTMLStencilElement {
    }
    var HTMLEsBadgeElement: {
        prototype: HTMLEsBadgeElement;
        new (): HTMLEsBadgeElement;
    };
    interface HTMLEsButtonElement extends Components.EsButton, HTMLStencilElement {
    }
    var HTMLEsButtonElement: {
        prototype: HTMLEsButtonElement;
        new (): HTMLEsButtonElement;
    };
    interface HTMLEsButtonLinkElement extends Components.EsButtonLink, HTMLStencilElement {
    }
    var HTMLEsButtonLinkElement: {
        prototype: HTMLEsButtonLinkElement;
        new (): HTMLEsButtonLinkElement;
    };
    interface HTMLEsCalloutElement extends Components.EsCallout, HTMLStencilElement {
    }
    var HTMLEsCalloutElement: {
        prototype: HTMLEsCalloutElement;
        new (): HTMLEsCalloutElement;
    };
    interface HTMLEsCopyElement extends Components.EsCopy, HTMLStencilElement {
    }
    var HTMLEsCopyElement: {
        prototype: HTMLEsCopyElement;
        new (): HTMLEsCopyElement;
    };
    interface HTMLEsCornerBannerElement extends Components.EsCornerBanner, HTMLStencilElement {
    }
    var HTMLEsCornerBannerElement: {
        prototype: HTMLEsCornerBannerElement;
        new (): HTMLEsCornerBannerElement;
    };
    interface HTMLEsCounterElement extends Components.EsCounter, HTMLStencilElement {
    }
    var HTMLEsCounterElement: {
        prototype: HTMLEsCounterElement;
        new (): HTMLEsCounterElement;
    };
    interface HTMLEsIconElement extends Components.EsIcon, HTMLStencilElement {
    }
    var HTMLEsIconElement: {
        prototype: HTMLEsIconElement;
        new (): HTMLEsIconElement;
    };
    interface HTMLEsModalElement extends Components.EsModal, HTMLStencilElement {
    }
    var HTMLEsModalElement: {
        prototype: HTMLEsModalElement;
        new (): HTMLEsModalElement;
    };
    interface HTMLEsPaginationElement extends Components.EsPagination, HTMLStencilElement {
    }
    var HTMLEsPaginationElement: {
        prototype: HTMLEsPaginationElement;
        new (): HTMLEsPaginationElement;
    };
    interface HTMLEsPopoverElement extends Components.EsPopover, HTMLStencilElement {
    }
    var HTMLEsPopoverElement: {
        prototype: HTMLEsPopoverElement;
        new (): HTMLEsPopoverElement;
    };
    interface HTMLEsPopperElement extends Components.EsPopper, HTMLStencilElement {
    }
    var HTMLEsPopperElement: {
        prototype: HTMLEsPopperElement;
        new (): HTMLEsPopperElement;
    };
    interface HTMLEsPopperInnerElement extends Components.EsPopperInner, HTMLStencilElement {
    }
    var HTMLEsPopperInnerElement: {
        prototype: HTMLEsPopperInnerElement;
        new (): HTMLEsPopperInnerElement;
    };
    interface HTMLEsPortalElement extends Components.EsPortal, HTMLStencilElement {
    }
    var HTMLEsPortalElement: {
        prototype: HTMLEsPortalElement;
        new (): HTMLEsPortalElement;
    };
    interface HTMLEsProgressionElement extends Components.EsProgression, HTMLStencilElement {
    }
    var HTMLEsProgressionElement: {
        prototype: HTMLEsProgressionElement;
        new (): HTMLEsProgressionElement;
    };
    interface HTMLEsResizeObserverElement extends Components.EsResizeObserver, HTMLStencilElement {
    }
    var HTMLEsResizeObserverElement: {
        prototype: HTMLEsResizeObserverElement;
        new (): HTMLEsResizeObserverElement;
    };
    interface HTMLEsStatusElement extends Components.EsStatus, HTMLStencilElement {
    }
    var HTMLEsStatusElement: {
        prototype: HTMLEsStatusElement;
        new (): HTMLEsStatusElement;
    };
    interface HTMLEsTableElement extends Components.EsTable, HTMLStencilElement {
    }
    var HTMLEsTableElement: {
        prototype: HTMLEsTableElement;
        new (): HTMLEsTableElement;
    };
    interface HTMLEsTableDetailElement extends Components.EsTableDetail, HTMLStencilElement {
    }
    var HTMLEsTableDetailElement: {
        prototype: HTMLEsTableDetailElement;
        new (): HTMLEsTableDetailElement;
    };
    interface HTMLEsTableDetailHeaderElement extends Components.EsTableDetailHeader, HTMLStencilElement {
    }
    var HTMLEsTableDetailHeaderElement: {
        prototype: HTMLEsTableDetailHeaderElement;
        new (): HTMLEsTableDetailHeaderElement;
    };
    interface HTMLEsTableNestedElement extends Components.EsTableNested, HTMLStencilElement {
    }
    var HTMLEsTableNestedElement: {
        prototype: HTMLEsTableNestedElement;
        new (): HTMLEsTableNestedElement;
    };
    interface HTMLEsTabsElement extends Components.EsTabs, HTMLStencilElement {
    }
    var HTMLEsTabsElement: {
        prototype: HTMLEsTabsElement;
        new (): HTMLEsTabsElement;
    };
    interface HTMLEsThinkingButtonElement extends Components.EsThinkingButton, HTMLStencilElement {
    }
    var HTMLEsThinkingButtonElement: {
        prototype: HTMLEsThinkingButtonElement;
        new (): HTMLEsThinkingButtonElement;
    };
    interface HTMLEsToastElement extends Components.EsToast, HTMLStencilElement {
    }
    var HTMLEsToastElement: {
        prototype: HTMLEsToastElement;
        new (): HTMLEsToastElement;
    };
    interface HTMLEsToasterElement extends Components.EsToaster, HTMLStencilElement {
    }
    var HTMLEsToasterElement: {
        prototype: HTMLEsToasterElement;
        new (): HTMLEsToasterElement;
    };
    interface HTMLEsWizardElement extends Components.EsWizard, HTMLStencilElement {
    }
    var HTMLEsWizardElement: {
        prototype: HTMLEsWizardElement;
        new (): HTMLEsWizardElement;
    };
    interface HTMLElementTagNameMap {
        "es-accordian": HTMLEsAccordianElement;
        "es-backdrop": HTMLEsBackdropElement;
        "es-badge": HTMLEsBadgeElement;
        "es-button": HTMLEsButtonElement;
        "es-button-link": HTMLEsButtonLinkElement;
        "es-callout": HTMLEsCalloutElement;
        "es-copy": HTMLEsCopyElement;
        "es-corner-banner": HTMLEsCornerBannerElement;
        "es-counter": HTMLEsCounterElement;
        "es-icon": HTMLEsIconElement;
        "es-modal": HTMLEsModalElement;
        "es-pagination": HTMLEsPaginationElement;
        "es-popover": HTMLEsPopoverElement;
        "es-popper": HTMLEsPopperElement;
        "es-popper-inner": HTMLEsPopperInnerElement;
        "es-portal": HTMLEsPortalElement;
        "es-progression": HTMLEsProgressionElement;
        "es-resize-observer": HTMLEsResizeObserverElement;
        "es-status": HTMLEsStatusElement;
        "es-table": HTMLEsTableElement;
        "es-table-detail": HTMLEsTableDetailElement;
        "es-table-detail-header": HTMLEsTableDetailHeaderElement;
        "es-table-nested": HTMLEsTableNestedElement;
        "es-tabs": HTMLEsTabsElement;
        "es-thinking-button": HTMLEsThinkingButtonElement;
        "es-toast": HTMLEsToastElement;
        "es-toaster": HTMLEsToasterElement;
        "es-wizard": HTMLEsWizardElement;
    }
}
declare namespace LocalJSX {
    interface EsAccordian {
        /**
          * An array of sections to display.
         */
        "sections": AccordianSection[];
        /**
          * Display numbered counters beside each title.
         */
        "steps"?: boolean;
    }
    interface EsBackdrop {
        "onClosed"?: (event: EsBackdropCustomEvent<any>) => void;
        "onRequestClose"?: (event: EsBackdropCustomEvent<any>) => void;
        "showBackdrop"?: boolean;
    }
    interface EsBadge {
        /**
          * Choose the color variant of the badge
         */
        "color"?: HTMLEsCounterElement['color'];
        /**
          * What number to display in the counter (or if the dot should display)
         */
        "count": number;
        /**
          * Show the dot and counter even if the count 0 (or negative)
         */
        "showZero"?: boolean;
        /**
          * The base size (in px) of the counter (has no effect on the dot)
         */
        "size"?: number;
        /**
          * Select the display variant of the badge
         */
        "variant"?: BadgeVariant;
    }
    interface EsButton {
        /**
          * If the button is disabled. Prevents the user from interacting with the button: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * The default behavior of the button.
         */
        "type"?: string;
        /**
          * Which styling variant to use.
         */
        "variant"?: ButtonVariant;
    }
    interface EsButtonLink {
        /**
          * Class for the contained anchor element
         */
        "anchorClass"?: string;
        /**
          * Id for the contained anchor element
         */
        "anchorId"?: string;
        /**
          * Role for the contained anchor element
         */
        "anchorRole"?: string;
        /**
          * Tab Index for the contained anchor element
         */
        "anchorTabIndex"?: string;
        /**
          * Title for the contained anchor element
         */
        "anchorTitle"?: string;
        /**
          * If the link is disabled. Prevents the user from interacting with the link: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * Link is for an external site
         */
        "external"?: boolean;
        /**
          * If the button should navigate within the router context, or force a refresh.
         */
        "forceRefresh"?: boolean;
        /**
          * Target for link (eg: target="_blank")
         */
        "target"?: string;
        /**
          * Where the button should link to.
         */
        "url"?: string;
        /**
          * Which styling variant to use
         */
        "variant"?: ButtonVariant;
    }
    interface EsCallout {
        /**
          * Heading text.
         */
        "heading": string;
        /**
          * Override the variant icon.
         */
        "icon"?: IconDescription;
        /**
          * Which color set to use.
         */
        "variant"?: EsCalloutVariant;
    }
    interface EsCopy {
    }
    interface EsCornerBanner {
        /**
          * Which styling variant to use.
         */
        "variant"?: CornerBannerVariant;
        /**
          * X location of the banner.
         */
        "x"?: 'left' | 'right';
        /**
          * Y location of the banner
         */
        "y"?: 'top' | 'bottom';
    }
    interface EsCounter {
        /**
          * Choose the color variant of the counter
         */
        "color"?: CounterColor;
        /**
          * The number to display
         */
        "count"?: number;
        /**
          * The height of the counter that the rest of the dimensions scale from
         */
        "size"?: number;
        /**
          * The display style of the counter.
         */
        "variant"?: CounterVariant;
    }
    interface EsIcon {
        /**
          * Rotate the icon to a speciied angle.
         */
        "angle"?: number;
        /**
          * Which icon to display.
         */
        "icon": IconDescription;
        /**
          * The hight and width to scale the icon to.
         */
        "size"?: number;
        /**
          * Apply a spin animation.
         */
        "spin"?: boolean;
        /**
          * When spinning, should it spin clockwise or anticlockwise.
         */
        "spinDirection"?: 'clockwise' | 'antiClockwise';
    }
    interface EsModal {
        /**
          * If the modal should have a footer.
         */
        "footer"?: boolean;
        /**
          * If the modal should have a header.
         */
        "header"?: boolean;
        /**
          * Triggers when the modal requests to be closed.
         */
        "onRequestClose"?: (event: EsModalCustomEvent<void>) => void;
    }
    interface EsPagination {
        /**
          * Current Page.
         */
        "current": number;
        /**
          * Triggered when a pagination button is clicked
         */
        "onUpdate"?: (event: EsPaginationCustomEvent<PageChangeEventType>) => void;
        /**
          * Number of pages.
         */
        "pageCount"?: number;
    }
    interface EsPopover {
        /**
          * If the popover should render an arrow.
         */
        "arrow"?: boolean;
        /**
          * Pass an element to attach the popover to. (Defaults to the parent element.)
         */
        "attachTo"?: HTMLElement;
        /**
          * Constrain the size of the popover to the size of the attachment node.
         */
        "autoSize"?: Constrain;
        /**
          * If the popover should overlay a backdrop, to prevent external clicks.
         */
        "backdrop"?: boolean;
        /**
          * If the popover should request to close when focus is lost
         */
        "closeOnBlur"?: boolean;
        /**
          * Constrain the size of the popover inner to the size of the window.
         */
        "constrain"?: Constrain;
        /**
          * An array of allowed placements or enable / disable
         */
        "flip"?: Placement[] | boolean;
        /**
          * The maximum height to constrain to.
         */
        "maxHeight"?: number;
        /**
          * The maximum width to constrain to.
         */
        "maxWidth"?: number;
        /**
          * The offset away from the attachement element in px.
         */
        "offset"?: number;
        /**
          * Triggers when the popover requests to close.
         */
        "onRequestClose"?: (event: EsPopoverCustomEvent<any>) => void;
        /**
          * Toggles if the popover is open or not.
         */
        "open"?: boolean;
        /**
          * Where to place the popover in relation to the attachment point.
         */
        "placement"?: Placement;
        /**
          * Class name for the popper
         */
        "popperClass"?: string;
        /**
          * A query selecter to select the element to portal the popper to.
         */
        "target"?: string;
        /**
          * If the popover should trap focus within, and return focus on close.
         */
        "trapFocus"?: boolean;
        /**
          * What zIndex to place the popover in.
         */
        "zIndex"?: number;
    }
    interface EsPopper {
        "backdrop"?: boolean;
        "onRequestClose"?: (event: EsPopperCustomEvent<any>) => void;
        "trapFocus"?: boolean;
    }
    interface EsPopperInner {
    }
    interface EsPortal {
        /**
          * If the portal should overlay a backdrop, to prevent external clicks.
         */
        "backdrop"?: boolean;
        /**
          * The element to render.
         */
        "element": VNode;
        /**
          * Triggers when the popover requests to close.
         */
        "onRequestClose"?: (event: EsPortalCustomEvent<any>) => void;
        /**
          * If the element is portaled or not.
         */
        "open"?: boolean;
        /**
          * A query selector to select the location to portal to.
         */
        "target"?: string;
    }
    interface EsProgression {
        /**
          * A list of checkpoints to display.
         */
        "checkpoints": Checkpoint[];
        /**
          * The current active location.
         */
        "location": string;
        /**
          * Emitted when a checkpoint is clicked.
         */
        "onProgressionRequest"?: (event: EsProgressionCustomEvent<string>) => void;
    }
    interface EsResizeObserver {
        /**
          * Triggered when the size of the element changes.
         */
        "onSizeChanged"?: (event: EsResizeObserverCustomEvent<DOMRectReadOnly>) => void;
    }
    interface EsStatus {
        "status": Status;
    }
    interface EsTable {
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: string[];
        /**
          * Sync function for extracting the data from the row. By default, it assumes you passed an array of data as your columns.
         */
        "getCellData"?: (key: string) => any;
        /**
          * Do not render header.
         */
        "headless"?: boolean;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier"?: string;
        /**
          * A function to calculate a href from the cell data.
         */
        "linkRowTo"?: (row: any) => string;
        /**
          * Triggered whenever a row is clicked. The `detail` is the item in the row array.
         */
        "onClickRow"?: (event: EsTableCustomEvent<any>) => void;
        /**
          * Allows rendering a node after the row.
         */
        "renderExpansion"?: (key: string) => VNode | null;
        /**
          * A function to calculate the class or classes of the row from the cellData.
         */
        "rowClass"?: (
        row: any,
    ) => Record<string, boolean> | string | undefined;
        /**
          * If rows should be allowed to take focus
         */
        "rowTakesFocus"?: boolean;
        /**
          * An array of rows to render. Each item in the array is passed to getCellData, to allow passing keys or other identifiers.
         */
        "rows": any[];
    }
    interface EsTableDetail {
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: Array<string>;
        /**
          * The data to render.
         */
        "data": any;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier"?: string;
    }
    interface EsTableDetailHeader {
        /**
          * Which cell to place in the top right as a list of actions.
         */
        "actionsCell"?: string;
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any>;
        /**
          * The data to render.
         */
        "data": any;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier"?: string;
        /**
          * Which cell to place as the title
         */
        "titleCell"?: string;
    }
    interface EsTableNested {
        /**
          * A path to a the currently active row, to auto expand its parent and show it as selected.
         */
        "activePath"?: string[];
        /**
          * Function to decide if a row can take expand, to show a nested table.
         */
        "canExpand"?: (key: string, data: any) => boolean;
        /**
          * Function to decide if a row can expand more, to show more rows in the nested table.
         */
        "canExpandMore"?: (key: string, count: number) => boolean;
        /**
          * A record of table cell definitions.Some built in cells are cells are available for use: - `--borderless`: A blank placeholder cell with no border, for aligning with the parent cell. - `--no-pad`: A blank placeholder cell, for aligning with the parent cell. - `expander`: The expander button.
         */
        "cells": TableCells<any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: string[];
        /**
          * Number number of rows to display in expansion
         */
        "expandBy"?: number;
        /**
          * Sync function for extracting the data from the row. By default, it assumes you passed an array of data as your columns.
         */
        "getCellData"?: (key: string) => any;
        /**
          * Sync function for extracting the data from the nested row. By default, it assumes you passed an array of data as your columns.
         */
        "getNestedCellData"?: (key: string) => any;
        /**
          * Sync function for extracting a list of rows for the nested table
         */
        "getNestedRows"?: (key: string, count: number) => any[] | undefined;
        /**
          * A function to calculate a href from the cell data.
         */
        "linkRowTo"?: (row: any) => string;
        /**
          * async function for loading nested data when a row is expanded.
         */
        "loadNested"?: (key: string, data: any) => Promise<void>;
        /**
          * The order and keys of the cells to be rendered in a nested table. If omitted, all cells will be rendered.
         */
        "nestedColumns"?: string[];
        /**
          * Passed to cell renderer as `parent`.
         */
        "nestedIdentifier"?: string;
        /**
          * If the nested rows should be allowed to take focus.
         */
        "nestedRowTakesFocus"?: boolean;
        /**
          * Triggered whenever a row (or nested row) is clicked. The `detail` is the item in the row array.
         */
        "onClickRow"?: (event: EsTableNestedCustomEvent<any>) => void;
        /**
          * Triggered whenever a row is expanded.
         */
        "onExpansion"?: (event: EsTableNestedCustomEvent<{ data: any; key: string }>) => void;
        /**
          * Passed to cell renderer as `parent`.
         */
        "outerIdentifier"?: string;
        /**
          * A function to calculate the class or classes of the row from the cellData.
         */
        "rowClass"?: (
        row: any,
    ) => Record<string, boolean> | string | undefined;
        /**
          * If rows should be allowed to take focus
         */
        "rowTakesFocus"?: boolean;
        /**
          * An array of rows to render. Each item in the array is passed to getCellData, to allow passing keys or other identifiers.
         */
        "rows": any[];
    }
    interface EsTabs {
        /**
          * The currently active panel. By default it will take from the passed activeParam, or the first tab.
         */
        "active"?: string;
        /**
          * Reflect the active tab to a search param of name. Set to false to disable.
         */
        "activeParam"?: string | false;
        /**
          * Triggered when the active tab is changed. `detail` is the newly active tab.
         */
        "onTabChange"?: (event: EsTabsCustomEvent<string>) => void;
        /**
          * A list of tabs.
         */
        "tabs": Tab[];
    }
    interface EsThinkingButton {
        /**
          * The async action to be called on click.
         */
        "action": (e: MouseEvent) => Promise<unknown>;
        /**
          * The icon to display when the action completed successfully.
         */
        "completeIcon"?: IconDescription;
        /**
          * The default icon to display when nothing is happening.
         */
        "defaultIcon": IconDescription;
        /**
          * If the button is disabled. Prevents the user from interacting with the button: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * The icon to display when the action errored out.
         */
        "failedIcon"?: IconDescription;
        /**
          * Optional text of the button
         */
        "text"?: string;
        /**
          * The icon to display when we are awaiting the action.
         */
        "thinkingIcon"?: IconDescription;
        /**
          * Which styling variant to use.
         */
        "variant"?: HTMLEsButtonElement['variant'];
    }
    interface EsToast {
        "count": Toast['count'];
        "icon": Toast['icon'];
        "level": ToastLevel;
    }
    interface EsToaster {
    }
    interface EsWizard {
        /**
          * The currently active page
         */
        "location": string;
        /**
          * A list of pages describing each step.
         */
        "pages": WizardPage[];
        /**
          * Offset the scroll to top on page change
         */
        "scrollOffset"?: number;
    }
    interface IntrinsicElements {
        "es-accordian": EsAccordian;
        "es-backdrop": EsBackdrop;
        "es-badge": EsBadge;
        "es-button": EsButton;
        "es-button-link": EsButtonLink;
        "es-callout": EsCallout;
        "es-copy": EsCopy;
        "es-corner-banner": EsCornerBanner;
        "es-counter": EsCounter;
        "es-icon": EsIcon;
        "es-modal": EsModal;
        "es-pagination": EsPagination;
        "es-popover": EsPopover;
        "es-popper": EsPopper;
        "es-popper-inner": EsPopperInner;
        "es-portal": EsPortal;
        "es-progression": EsProgression;
        "es-resize-observer": EsResizeObserver;
        "es-status": EsStatus;
        "es-table": EsTable;
        "es-table-detail": EsTableDetail;
        "es-table-detail-header": EsTableDetailHeader;
        "es-table-nested": EsTableNested;
        "es-tabs": EsTabs;
        "es-thinking-button": EsThinkingButton;
        "es-toast": EsToast;
        "es-toaster": EsToaster;
        "es-wizard": EsWizard;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "es-accordian": LocalJSX.EsAccordian & JSXBase.HTMLAttributes<HTMLEsAccordianElement>;
            "es-backdrop": LocalJSX.EsBackdrop & JSXBase.HTMLAttributes<HTMLEsBackdropElement>;
            "es-badge": LocalJSX.EsBadge & JSXBase.HTMLAttributes<HTMLEsBadgeElement>;
            "es-button": LocalJSX.EsButton & JSXBase.HTMLAttributes<HTMLEsButtonElement>;
            "es-button-link": LocalJSX.EsButtonLink & JSXBase.HTMLAttributes<HTMLEsButtonLinkElement>;
            "es-callout": LocalJSX.EsCallout & JSXBase.HTMLAttributes<HTMLEsCalloutElement>;
            "es-copy": LocalJSX.EsCopy & JSXBase.HTMLAttributes<HTMLEsCopyElement>;
            "es-corner-banner": LocalJSX.EsCornerBanner & JSXBase.HTMLAttributes<HTMLEsCornerBannerElement>;
            "es-counter": LocalJSX.EsCounter & JSXBase.HTMLAttributes<HTMLEsCounterElement>;
            "es-icon": LocalJSX.EsIcon & JSXBase.HTMLAttributes<HTMLEsIconElement>;
            "es-modal": LocalJSX.EsModal & JSXBase.HTMLAttributes<HTMLEsModalElement>;
            "es-pagination": LocalJSX.EsPagination & JSXBase.HTMLAttributes<HTMLEsPaginationElement>;
            "es-popover": LocalJSX.EsPopover & JSXBase.HTMLAttributes<HTMLEsPopoverElement>;
            "es-popper": LocalJSX.EsPopper & JSXBase.HTMLAttributes<HTMLEsPopperElement>;
            "es-popper-inner": LocalJSX.EsPopperInner & JSXBase.HTMLAttributes<HTMLEsPopperInnerElement>;
            "es-portal": LocalJSX.EsPortal & JSXBase.HTMLAttributes<HTMLEsPortalElement>;
            "es-progression": LocalJSX.EsProgression & JSXBase.HTMLAttributes<HTMLEsProgressionElement>;
            "es-resize-observer": LocalJSX.EsResizeObserver & JSXBase.HTMLAttributes<HTMLEsResizeObserverElement>;
            "es-status": LocalJSX.EsStatus & JSXBase.HTMLAttributes<HTMLEsStatusElement>;
            "es-table": LocalJSX.EsTable & JSXBase.HTMLAttributes<HTMLEsTableElement>;
            "es-table-detail": LocalJSX.EsTableDetail & JSXBase.HTMLAttributes<HTMLEsTableDetailElement>;
            "es-table-detail-header": LocalJSX.EsTableDetailHeader & JSXBase.HTMLAttributes<HTMLEsTableDetailHeaderElement>;
            "es-table-nested": LocalJSX.EsTableNested & JSXBase.HTMLAttributes<HTMLEsTableNestedElement>;
            "es-tabs": LocalJSX.EsTabs & JSXBase.HTMLAttributes<HTMLEsTabsElement>;
            "es-thinking-button": LocalJSX.EsThinkingButton & JSXBase.HTMLAttributes<HTMLEsThinkingButtonElement>;
            "es-toast": LocalJSX.EsToast & JSXBase.HTMLAttributes<HTMLEsToastElement>;
            "es-toaster": LocalJSX.EsToaster & JSXBase.HTMLAttributes<HTMLEsToasterElement>;
            "es-wizard": LocalJSX.EsWizard & JSXBase.HTMLAttributes<HTMLEsWizardElement>;
        }
    }
}
