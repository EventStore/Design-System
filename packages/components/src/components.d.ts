/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { AccordianSection } from "./components/accordian/types";
import { IconDescription } from "./components/icon/types";
import { ConfirmModalOptions } from "./components/modals/confirm-modal/types";
import { RenderFunction } from "./types";
import { BadgeVariant } from "./components/badge/badge";
import { ButtonVariant } from "./components/buttons/types";
import { EsCalloutVariant } from "./components/callout/callout";
import { FunctionalComponent } from "@stencil/core";
import { CornerBannerVariant } from "./components/corner-banner/corner-banner";
import { CounterColor, CounterVariant } from "./components/counter/types";
import { PageChangeEventType } from "./components/pagination/types";
import { Constrain, Placement } from "./components/popover/types";
import { Checkpoint, CheckpointState } from "./components/progression/types";
import { ClickRow, JumpOptions, LoadWindow, TableCells, TableSort } from "./components/tables/types";
import { Tab } from "./components/tabs/types";
import { Toast, ToastLevel, ToastOptions } from "./components/toast/types";
import { WizardPage } from "./components/wizard/types";
export { AccordianSection } from "./components/accordian/types";
export { IconDescription } from "./components/icon/types";
export { ConfirmModalOptions } from "./components/modals/confirm-modal/types";
export { RenderFunction } from "./types";
export { BadgeVariant } from "./components/badge/badge";
export { ButtonVariant } from "./components/buttons/types";
export { EsCalloutVariant } from "./components/callout/callout";
export { FunctionalComponent } from "@stencil/core";
export { CornerBannerVariant } from "./components/corner-banner/corner-banner";
export { CounterColor, CounterVariant } from "./components/counter/types";
export { PageChangeEventType } from "./components/pagination/types";
export { Constrain, Placement } from "./components/popover/types";
export { Checkpoint, CheckpointState } from "./components/progression/types";
export { ClickRow, JumpOptions, LoadWindow, TableCells, TableSort } from "./components/tables/types";
export { Tab } from "./components/tabs/types";
export { Toast, ToastLevel, ToastOptions } from "./components/toast/types";
export { WizardPage } from "./components/wizard/types";
export namespace Components {
    /**
     * Optionally collapsible sectioned view. Each section can be targeted via a part.
     */
    interface C2Accordian {
        /**
          * An array of sections to display.
         */
        "sections": AccordianSection[];
        /**
          * Display numbered counters beside each title.
         */
        "steps": boolean;
    }
    /**
     * A generic button action.
     */
    interface C2Action {
        /**
          * The action to take when the button is clicked.
         */
        "action": (e: MouseEvent) => any;
        /**
          * If the action should be disabled.
         */
        "disabled": boolean;
        /**
          * If a dot should be shown on the action, to indicate attention being required.
         */
        "dot"?: HTMLC2BadgeElement['color'];
        /**
          * If the action is within an `c2-action-dropdown`.
         */
        "dropdownItem": boolean;
        /**
          * The icon to show for the action.
         */
        "icon": IconDescription;
    }
    /**
     * A dropdown to display more actions than can be reasonably fit in a row.
     * All child actions must have the `dropdownItem` prop set.
     */
    interface C2ActionDropdown {
        /**
          * If the dropdown should be disabled.
         */
        "disabled": boolean;
        /**
          * The icon to show for the action.
         */
        "icon": IconDescription;
    }
    /**
     * A link action.
     */
    interface C2ActionLink {
        /**
          * If the action should be disabled.
         */
        "disabled": boolean;
        /**
          * If a dot should be shown on the action, to indicate attention being required.
         */
        "dot"?: HTMLC2BadgeElement['color'];
        /**
          * If the action is within an `c2-action-dropdown`.
         */
        "dropdownItem": boolean;
        /**
          * The icon to show for the action.
         */
        "icon": IconDescription;
        /**
          * The url to go to when clicked.
         */
        "url": string;
    }
    /**
     * An action with a confirmation modal.
     */
    interface C2ActionWithConfirmation {
        /**
          * The action to take when the button is clicked.
         */
        "action": () => any;
        /**
          * if the action should be disabled.
         */
        "disabled": boolean;
        /**
          * If a dot should be shown on the action, to indicate attention being required.
         */
        "dot"?: HTMLC2BadgeElement['color'];
        /**
          * If the action is within an `c2-action-dropdown`.
         */
        "dropdownItem": boolean;
        /**
          * The icon to show for the action.
         */
        "icon": IconDescription;
        /**
          * The text to display within the modal.
         */
        "modal": ConfirmModalOptions;
        /**
          * If the user needs to type the passed string to enable confirmation.
         */
        "typeToConfirm"?: string;
    }
    /**
     * A container for `c2-action-*` elements, to be used in tables or panel headers.
     */
    interface C2Actions {
    }
    interface C2Backdrop {
        "cancelClose": () => Promise<void>;
        "close": () => Promise<boolean>;
        "preventOverscroll": boolean;
        "renderNode": (node: RenderFunction) => Promise<void>;
        "showBackdrop": boolean;
    }
    /**
     * Display a counter or dot beside a component to indicate action being required.
     */
    interface C2Badge {
        /**
          * Choose the color variant of the badge
         */
        "color": HTMLC2CounterElement['color'];
        /**
          * What number to display in the counter (or if the dot should display)
         */
        "count": number;
        /**
          * Show the dot and counter even if the count 0 (or negative)
         */
        "showZero": boolean;
        /**
          * The base size (in px) of the counter (has no effect on the dot)
         */
        "size"?: number;
        /**
          * Select the display variant of the badge
         */
        "variant": BadgeVariant;
    }
    /**
     * A button.
     */
    interface C2Button {
        /**
          * If the button is disabled. Prevents the user from interacting with the button: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * The default behavior of the button.
         */
        "type": string;
        /**
          * Which styling variant to use.
         */
        "variant": ButtonVariant;
    }
    /**
     * Anchor link version of c2-button, wraps a `Link` from `@kurrent-ui/router`.
     */
    interface C2ButtonLink {
        /**
          * Class for the contained anchor element
         */
        "anchorClass"?: string;
        /**
          * Id for the contained anchor element
         */
        "anchorId"?: string;
        /**
          * Role for the contained anchor element
         */
        "anchorRole"?: string;
        /**
          * Tab Index for the contained anchor element
         */
        "anchorTabIndex"?: string;
        /**
          * Title for the contained anchor element
         */
        "anchorTitle"?: string;
        /**
          * If the link is disabled. Prevents the user from interacting with the link: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * Link is for an external site
         */
        "external"?: boolean;
        /**
          * If the button should navigate within the router context, or force a refresh.
         */
        "forceRefresh"?: boolean;
        /**
          * Target for link (eg: target="_blank")
         */
        "target"?: string;
        /**
          * Where the button should link to.
         */
        "url"?: string;
        /**
          * Which styling variant to use
         */
        "variant": ButtonVariant;
    }
    /**
     * A button with a confirmation modal.
     */
    interface C2ButtonWithConfirmation {
        /**
          * The action to be called on click.
         */
        "action": () => any;
        /**
          * If the button is disabled. Prevents the user from interacting with the button: it cannot be pressed or focused.
         */
        "disabled": boolean;
        /**
          * The text to display within the modal.
         */
        "modal": ConfirmModalOptions;
        /**
          * The default behavior of the button.
         */
        "type": string;
        /**
          * If the user needs to type the passed string to enable confirmation.
         */
        "typeToConfirm"?: string;
        /**
          * Which styling variant to use.
         */
        "variant": ButtonVariant;
    }
    /**
     * Calls out a piece of information.
     */
    interface C2Callout {
        /**
          * Heading text.
         */
        "heading": string;
        /**
          * Override the variant icon.
         */
        "icon"?: IconDescription;
        /**
          * Which color set to use.
         */
        "variant": EsCalloutVariant;
    }
    /**
     * A modal to confirm an action.
     */
    interface C2ConfirmModal {
        /**
          * Text or component to display in the body of the modal.
         */
        "body": string | FunctionalComponent;
        /**
          * Text to display within the confirm button.
         */
        "confirm": string;
        /**
          * Button variant for the confirm button.
         */
        "confirmVariant": ButtonVariant;
        /**
          * Text to display in the heading.
         */
        "heading": string;
        /**
          * Text to display above the heading.
         */
        "preHeading": string;
        /**
          * String required to be typed to enable the confirm button.
         */
        "typeToConfirm"?: string;
        /**
          * Text to display in red below the body.
         */
        "warning"?: string;
    }
    /**
     * Copies the text passed as a child when clicked.
     */
    interface C2Copy {
        /**
          * Manually triggers the copy of the inner text.
         */
        "copy": () => Promise<void>;
    }
    /**
     * Display a banner with text in the corner.
     */
    interface C2CornerBanner {
        /**
          * Which styling variant to use.
         */
        "variant": CornerBannerVariant;
        /**
          * X location of the banner.
         */
        "x": 'left' | 'right';
        /**
          * Y location of the banner
         */
        "y": 'top' | 'bottom';
    }
    /**
     * A pill display of an number, that pulses on change. Caps out at 999.
     */
    interface C2Counter {
        /**
          * Choose the color variant of the counter
         */
        "color"?: CounterColor;
        /**
          * The number to display
         */
        "count": number;
        /**
          * The height of the counter that the rest of the dimensions scale from
         */
        "size": number;
        /**
          * The display style of the counter.
         */
        "variant": CounterVariant;
    }
    /**
     * Punches a hole through all parent shadow DOMs into the light DOM.
     * Any slotted chlid will be moved into the light, and a chain of slots
     * brings the slotted children back into position.
     */
    interface C2HolePuncher {
        /**
          * Prefix the generated slot name, to allow easier identification in the DOM
         */
        "namePrefix": string;
    }
    /**
     * Displays an icon loaded from the `iconStore`. An icon named "spinner" will automatically spin.
     * See [IconStore](/components/variables/iconStore) for details on how to load icons.
     */
    interface C2Icon {
        /**
          * Rotate the icon to a speciied angle.
         */
        "angle": number;
        /**
          * Which icon to display.
         */
        "icon": IconDescription;
        /**
          * The hight and width to scale the icon to.
         */
        "size": number;
        /**
          * Apply a spin animation.
         */
        "spin"?: boolean;
        /**
          * When spinning, should it spin clockwise or anticlockwise.
         */
        "spinDirection": 'clockwise' | 'antiClockwise';
        /**
          * Provides a promise that resolves at the end of a single spin, if the icon is spinning.
         */
        "spinEnd": () => Promise<void>;
    }
    /**
     * Display a row of five pulsing dots, to indicate loading.
     */
    interface C2LoadingDots {
    }
    /**
     * Displays a grey block to placehold loading text.
     */
    interface C2LoadingText {
        /**
          * The expected loaded text length.
         */
        "expectedLength": number;
        /**
          * Adds a random number of chars (up to the passed amount)
         */
        "variance"?: number;
    }
    /**
     * A pop up modal for overlaying information, warnings and confirmations.
     * Traps focus within the modal, and returns focus to previous location when closed.
     * Pair with an [`c2-portal`](/components/components/portal) to open and close.
     */
    interface C2Modal {
        /**
          * If the modal should have a footer.
         */
        "footer": boolean;
        /**
          * If the modal should have a header.
         */
        "header": boolean;
    }
    /**
     * Page navigation with ability to jump to first and last pages with `pageCount` is provided.
     */
    interface C2Pagination {
        /**
          * Current Page.
         */
        "current": number;
        /**
          * Number of pages.
         */
        "pageCount"?: number;
    }
    /**
     * Attaches a portaled popover, attached to the parent node. Can be used to create dropdowns, tooltips etc. The parent scoped shadow styles are copied to the created portals shadow styles, to allow styling popover contents externally.
     */
    interface C2Popover {
        /**
          * If the popover should render an arrow.
         */
        "arrow": boolean;
        /**
          * Pass an element to attach the popover to. (Defaults to the parent element.)
         */
        "attachTo"?: HTMLElement;
        /**
          * Constrain the size of the popover to the size of the attachment node.
         */
        "autoSize": Constrain;
        /**
          * If the popover should overlay a backdrop, to prevent external clicks.
         */
        "backdrop": boolean;
        /**
          * If the popover should request to close when focus is lost
         */
        "closeOnBlur": boolean;
        /**
          * If the popover should request to close when clicked outside
         */
        "closeOnClickOutside": boolean;
        /**
          * If the popover should request to close when esc is pressed
         */
        "closeOnEsc": boolean;
        /**
          * If the popover should request to close when the attachment element scrolls out of view
         */
        "closeOnScrollEscape": boolean;
        /**
          * Constrain the size of the popover inner to the size of the window.
         */
        "constrain": Constrain;
        /**
          * An array of allowed placements or enable / disable
         */
        "flip"?: Placement[] | boolean;
        /**
          * If the popover should hide itself when the attachment element scrolls out of view
         */
        "hideOnScrollEscape": boolean;
        /**
          * The maximum height to constrain to.
         */
        "maxHeight": number;
        /**
          * The maximum width to constrain to.
         */
        "maxWidth": number;
        /**
          * The offset away from the attachement element in px.
         */
        "offset": number;
        /**
          * Toggles if the popover is open or not.
         */
        "open": boolean;
        /**
          * Where to place the popover in relation to the attachment point.
         */
        "placement": Placement;
        /**
          * Class name for the popper
         */
        "popperClass"?: string;
        /**
          * A query selecter to select the element to portal the popper to.
         */
        "target": string;
        /**
          * If the popover should trap focus within, and return focus on close.
         */
        "trapFocus": boolean;
        /**
          * What zIndex to place the popover in.
         */
        "zIndex"?: number;
    }
    interface C2Popper {
        "backdrop": boolean;
        "loaded": () => Promise<boolean>;
        "trapFocus": boolean;
    }
    interface C2PopperInner {
    }
    interface C2PopperX {
    }
    interface C2PopperY {
    }
    /**
     * Portals the passed node to a different part of the document. Note that portal does not transfer shadow scoped styles, unlike `c2-popover`, so any portaled elements should be self contained.
     */
    interface C2Portal {
        "attachElement": () => Promise<void>;
        /**
          * If the portal should overlay a backdrop, to prevent external clicks.
         */
        "backdrop": boolean;
        "detatchElement": () => Promise<void>;
        /**
          * If the element is portaled or not.
         */
        "open": boolean;
        /**
          * If the portal should prevent overscroll
         */
        "preventOverscroll": boolean;
        /**
          * The element to render.
         */
        "renderElement": RenderFunction;
        /**
          * A query selector to select the location to portal to.
         */
        "target": string;
    }
    /**
     * A wizard progression bar.
     */
    interface C2Progression {
        /**
          * A list of checkpoints to display.
         */
        "checkpoints": Checkpoint[];
        /**
          * Set custom colors for all checkpoints
         */
        "colors"?: Partial<Record<CheckpointState, string>>;
        /**
          * Set custom icons for all checkpoints
         */
        "icons"?: Partial<Record<CheckpointState, IconDescription>>;
        /**
          * The current active location.
         */
        "location": string;
        /**
          * Disable interactivity.
         */
        "readonly"?: boolean;
    }
    /**
     * Wraps a [ResizeObserver](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver) to allow tracking `DOMRect` dimensions
     */
    interface C2ResizeObserver {
    }
    /**
     * Create a table from data.
     */
    interface C2Table {
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any, any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: string[];
        /**
          * Pass extra props to cells
         */
        "extraCellProps"?: (key: string, data: any) => Record<string, any>;
        /**
          * Sync function for extracting the data from the row. By default, it assumes you passed an array of data as your columns.
         */
        "getCellData": (row: any) => any;
        /**
          * Sync function for extracting a key from your row data. By default, if the passed rows are strings it will use them directly, otherwise it will warn and use the index.
         */
        "getRowKey": (row: any, i: number) => string;
        /**
          * Do not render header.
         */
        "headless": boolean;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier": string;
        /**
          * A function to calculate a href from the cell data.
         */
        "linkRowTo"?: (data: any) => string;
        /**
          * Indicates if the loading indicators should be displayed
         */
        "loading"?: boolean;
        /**
          * Specifies the number of rows to display when loading is true. Defaults to 1.
         */
        "loadingRows": number;
        /**
          * Allows rendering a node after the row.
         */
        "renderExpansion": RenderFunction<
        [row: any, key: string, i: number]
    >;
        /**
          * A function to calculate the class or classes of the row from the cellData.
         */
        "rowClass": (
        data: any,
        row: any,
    ) => Record<string, boolean> | string | undefined;
        /**
          * If rows should be allowed to take focus
         */
        "rowTakesFocus"?: boolean;
        /**
          * An array of rows to render. Each item in the array is passed to getCellData, to allow passing keys or other identifiers.
         */
        "rows": unknown[];
        /**
          * How the table is sorted
         */
        "sort"?: TableSort;
        /**
          * Header sticks to scroll parent.
         */
        "stickyHeader": boolean;
    }
    /**
     * Render a single row data as a grid of information.
     */
    interface C2TableDetail {
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any, any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: Array<string>;
        /**
          * The data to render.
         */
        "data": any;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier": string;
        /**
          * Indicates if the loading indicators should be displayed
         */
        "loading"?: boolean;
    }
    /**
     * A default header for [`c2-table-detail`](/components/components/table-detail).
     */
    interface C2TableDetailHeader {
        /**
          * Which cell to place in the top right as a list of actions.
         */
        "actionsCell": string;
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any, any>;
        /**
          * The data to render.
         */
        "data": any;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier": string;
        /**
          * Which cell to place as the title
         */
        "titleCell": string;
    }
    /**
     * Create a nested table from data.
     */
    interface C2TableNested {
        /**
          * A path to a the currently active row, to auto expand its parent and show it as selected.
         */
        "activePath"?: string[];
        /**
          * Function to decide if a row can take expand, to show a nested table.
         */
        "canExpand": (key: string, data: any, depth: number) => boolean;
        /**
          * Function to decide if a row can expand more, to show more rows in the nested table.
         */
        "canExpandMore": (key: string, count: number) => boolean;
        /**
          * A record of table cell definitions.Some built in cells are cells are available for use: - `--borderless`: A blank placeholder cell with no border, for aligning with the parent cell. - `--no-pad`: A blank placeholder cell, for aligning with the parent cell. - `--expander`: The expander button.
         */
        "cells": TableCells<any, any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: string[];
        /**
          * Number of rows to be expanded by default
         */
        "defaultExpanded"?: (key: string, depth: number) => number;
        /**
          * Number number of rows to display in expansion
         */
        "expandBy": number;
        /**
          * Pass extra props to cells
         */
        "extraCellProps"?: (key: string, data: any) => Record<string, any>;
        /**
          * Sync function for extracting the data from the row. By default, it assumes you passed an array of data as your columns.
         */
        "getCellData"?: (key: string) => any;
        /**
          * Sync function for extracting the data from the nested row. By default, it assumes you passed an array of data as your columns.
         */
        "getNestedCellData"?: (key: string) => any;
        /**
          * Sync function for extracting a key from your nested row data. By default, if the passed rows are strings it will use them directly, otherwise it will warn and use the index.
         */
        "getNestedRowKey"?: (row: any, i: number) => string;
        /**
          * Sync function for extracting a list of rows for the nested table
         */
        "getNestedRows"?: (key: string, count: number) => any[] | undefined;
        /**
          * Sync function for extracting a key from your row data. By default, if the passed rows are strings it will use them directly, otherwise it will warn and use the index.
         */
        "getRowKey"?: (row: any, i: number) => string;
        /**
          * Do not render header.
         */
        "headless": boolean;
        /**
          * A function to calculate a href from the cell data.
         */
        "linkRowTo"?: (row: any) => string;
        /**
          * async function for loading nested data when a row is expanded.
         */
        "loadNested"?: (key: string, data: any) => Promise<void>;
        /**
          * Indicates if the loading indicators should be displayed
         */
        "loading"?: boolean;
        /**
          * Specifies the number of rows to display when loading is true. Defaults to 1.
         */
        "loadingRows": number;
        /**
          * The order and keys of the cells to be rendered in a nested table. If omitted, all cells will be rendered.
         */
        "nestedColumns"?: string[];
        /**
          * Passed to cell renderer as `parent`.
         */
        "nestedIdentifier": string;
        /**
          * If the nested rows should be allowed to take focus.
         */
        "nestedRowTakesFocus"?: boolean;
        /**
          * Passed to cell renderer as `parent`.
         */
        "outerIdentifier": string;
        /**
          * A function to calculate the class or classes of the row from the cellData.
         */
        "rowClass": (
        row: any,
        key: string,
    ) => Record<string, boolean> | string | undefined;
        /**
          * If rows should be allowed to take focus
         */
        "rowTakesFocus"?: boolean;
        /**
          * An array of rows to render. Each item in the array is passed to getCellData, to allow passing keys or other identifiers.
         */
        "rows": any[];
        /**
          * Header sticks to scroll parent.
         */
        "stickyHeader": boolean;
        /**
          * If clicking a row should expand it.
         */
        "toggleRowOnClick": boolean;
    }
    /**
     * Create a virtualized table from data.
     */
    interface C2TableVirtualized {
        /**
          * The height (in pixels) of the after
         */
        "afterHeight": number;
        /**
          * The height (in pixels) of the before
         */
        "beforeHeight": number;
        /**
          * Groups rows into blocks
         */
        "blockSize": number;
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any, any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: string[];
        /**
          * Pass extra props to cells
         */
        "extraCellProps"?: (key: string, data: any) => Record<string, any>;
        /**
          * Sync function for extracting the data from the row. By default, it assumes you passed an array of data as your columns.
         */
        "getCellData": (key: string, index: number) => any;
        /**
          * Sync function for converting an index into a key
         */
        "getKeyFromIndex": (index: number) => string;
        /**
          * The height (in pixels) of the header
         */
        "headerHeight": number;
        /**
          * Do not render header.
         */
        "headless": boolean;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier": string;
        /**
          * Jump to the passed row, with smooth scroll and highlight, if specified.
         */
        "jumpToRow": (index: number, { highlight, smooth }?: Partial<JumpOptions>) => Promise<void>;
        /**
          * A function to calculate a href from the cell data.
         */
        "linkRowTo"?: (row: any) => string;
        /**
          * The size of the grid rows before starting a reflow
         */
        "reflowSize": number;
        /**
          * Display in a row after the last row
         */
        "renderAfter"?: RenderFunction;
        /**
          * Display in a row before the first row
         */
        "renderBefore"?: RenderFunction;
        /**
          * A function to calculate the class or classes of the row from the cellData.
         */
        "rowClass": (
        row: any,
        key: string,
        index: number,
    ) => Record<string, boolean> | string | undefined;
        /**
          * The total number of rows
         */
        "rowCount": number;
        /**
          * The height (in pixels) of the row
         */
        "rowHeight": number;
        /**
          * If rows should be allowed to take focus
         */
        "rowTakesFocus"?: boolean;
        /**
          * If the table should lock scroll on appending events
         */
        "scrollLock"?: boolean;
        /**
          * How the table is sorted
         */
        "sort"?: TableSort;
        /**
          * Header sticks to scroll parent.
         */
        "stickyHeader": boolean;
        /**
          * The size of the window to render
         */
        "windowSize": number;
    }
    /**
     * A tabbed panel. Each panel can be targeted via a slot.
     */
    interface C2Tabs {
        /**
          * The currently active panel. By default it will take from the passed activeParam, or the first tab.
         */
        "active"?: string;
        /**
          * Reflect the active tab to a search param of name. Set to false to disable.
         */
        "activeParam": string | false;
        /**
          * Icon to be rendered between each tab.
         */
        "interTabIcon"?: IconDescription;
        /**
          * thu size of the icon to be rendered between each tab.
         */
        "interTabIconSize": number;
        /**
          * A list of tabs.
         */
        "tabs": Tab[];
    }
    /**
     * A button with an icon that displays the state of a async action on click.
     */
    interface C2ThinkingButton {
        /**
          * The async action to be called on click.
         */
        "action": (e: MouseEvent) => Promise<unknown>;
        /**
          * The icon to display when the action completed successfully.
         */
        "completeIcon": IconDescription;
        /**
          * The default icon to display when nothing is happening.
         */
        "defaultIcon": IconDescription;
        /**
          * If the button is disabled. Prevents the user from interacting with the button: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * The icon to display when the action errored out.
         */
        "failedIcon": IconDescription;
        /**
          * Optional text of the button
         */
        "text"?: string;
        /**
          * The icon to display when we are awaiting the action.
         */
        "thinkingIcon": IconDescription;
        /**
          * Which styling variant to use.
         */
        "variant": HTMLC2ButtonElement['variant'];
    }
    interface C2Toast {
        "close": () => Promise<void>;
        "count": Toast['count'];
        "icon": Toast['icon'];
        "level": ToastLevel;
    }
    interface C2Toaster {
        "popToast": (level: ToastLevel | undefined, { message, title, duration, icon, onClick, }: ToastOptions) => Promise<() => void>;
    }
    /**
     * A multi step wizard. Each step can be targeted via a slot.
     */
    interface C2Wizard {
        /**
          * The currently active page
         */
        "location": string;
        /**
          * A list of pages describing each step.
         */
        "pages": WizardPage[];
        /**
          * Offset the scroll to top on page change
         */
        "scrollOffset": number;
    }
}
export interface C2BackdropCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLC2BackdropElement;
}
export interface C2ConfirmModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLC2ConfirmModalElement;
}
export interface C2ModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLC2ModalElement;
}
export interface C2PaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLC2PaginationElement;
}
export interface C2PopoverCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLC2PopoverElement;
}
export interface C2PopperCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLC2PopperElement;
}
export interface C2PortalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLC2PortalElement;
}
export interface C2ProgressionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLC2ProgressionElement;
}
export interface C2ResizeObserverCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLC2ResizeObserverElement;
}
export interface C2TableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLC2TableElement;
}
export interface C2TableNestedCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLC2TableNestedElement;
}
export interface C2TableVirtualizedCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLC2TableVirtualizedElement;
}
export interface C2TabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLC2TabsElement;
}
declare global {
    /**
     * Optionally collapsible sectioned view. Each section can be targeted via a part.
     */
    interface HTMLC2AccordianElement extends Components.C2Accordian, HTMLStencilElement {
    }
    var HTMLC2AccordianElement: {
        prototype: HTMLC2AccordianElement;
        new (): HTMLC2AccordianElement;
    };
    /**
     * A generic button action.
     */
    interface HTMLC2ActionElement extends Components.C2Action, HTMLStencilElement {
    }
    var HTMLC2ActionElement: {
        prototype: HTMLC2ActionElement;
        new (): HTMLC2ActionElement;
    };
    /**
     * A dropdown to display more actions than can be reasonably fit in a row.
     * All child actions must have the `dropdownItem` prop set.
     */
    interface HTMLC2ActionDropdownElement extends Components.C2ActionDropdown, HTMLStencilElement {
    }
    var HTMLC2ActionDropdownElement: {
        prototype: HTMLC2ActionDropdownElement;
        new (): HTMLC2ActionDropdownElement;
    };
    /**
     * A link action.
     */
    interface HTMLC2ActionLinkElement extends Components.C2ActionLink, HTMLStencilElement {
    }
    var HTMLC2ActionLinkElement: {
        prototype: HTMLC2ActionLinkElement;
        new (): HTMLC2ActionLinkElement;
    };
    /**
     * An action with a confirmation modal.
     */
    interface HTMLC2ActionWithConfirmationElement extends Components.C2ActionWithConfirmation, HTMLStencilElement {
    }
    var HTMLC2ActionWithConfirmationElement: {
        prototype: HTMLC2ActionWithConfirmationElement;
        new (): HTMLC2ActionWithConfirmationElement;
    };
    /**
     * A container for `c2-action-*` elements, to be used in tables or panel headers.
     */
    interface HTMLC2ActionsElement extends Components.C2Actions, HTMLStencilElement {
    }
    var HTMLC2ActionsElement: {
        prototype: HTMLC2ActionsElement;
        new (): HTMLC2ActionsElement;
    };
    interface HTMLC2BackdropElementEventMap {
        "requestClose": any;
        "closed": any;
    }
    interface HTMLC2BackdropElement extends Components.C2Backdrop, HTMLStencilElement {
        addEventListener<K extends keyof HTMLC2BackdropElementEventMap>(type: K, listener: (this: HTMLC2BackdropElement, ev: C2BackdropCustomEvent<HTMLC2BackdropElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLC2BackdropElementEventMap>(type: K, listener: (this: HTMLC2BackdropElement, ev: C2BackdropCustomEvent<HTMLC2BackdropElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLC2BackdropElement: {
        prototype: HTMLC2BackdropElement;
        new (): HTMLC2BackdropElement;
    };
    /**
     * Display a counter or dot beside a component to indicate action being required.
     */
    interface HTMLC2BadgeElement extends Components.C2Badge, HTMLStencilElement {
    }
    var HTMLC2BadgeElement: {
        prototype: HTMLC2BadgeElement;
        new (): HTMLC2BadgeElement;
    };
    /**
     * A button.
     */
    interface HTMLC2ButtonElement extends Components.C2Button, HTMLStencilElement {
    }
    var HTMLC2ButtonElement: {
        prototype: HTMLC2ButtonElement;
        new (): HTMLC2ButtonElement;
    };
    /**
     * Anchor link version of c2-button, wraps a `Link` from `@kurrent-ui/router`.
     */
    interface HTMLC2ButtonLinkElement extends Components.C2ButtonLink, HTMLStencilElement {
    }
    var HTMLC2ButtonLinkElement: {
        prototype: HTMLC2ButtonLinkElement;
        new (): HTMLC2ButtonLinkElement;
    };
    /**
     * A button with a confirmation modal.
     */
    interface HTMLC2ButtonWithConfirmationElement extends Components.C2ButtonWithConfirmation, HTMLStencilElement {
    }
    var HTMLC2ButtonWithConfirmationElement: {
        prototype: HTMLC2ButtonWithConfirmationElement;
        new (): HTMLC2ButtonWithConfirmationElement;
    };
    /**
     * Calls out a piece of information.
     */
    interface HTMLC2CalloutElement extends Components.C2Callout, HTMLStencilElement {
    }
    var HTMLC2CalloutElement: {
        prototype: HTMLC2CalloutElement;
        new (): HTMLC2CalloutElement;
    };
    interface HTMLC2ConfirmModalElementEventMap {
        "requestClose": any;
        "requestDeletion": any;
    }
    /**
     * A modal to confirm an action.
     */
    interface HTMLC2ConfirmModalElement extends Components.C2ConfirmModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLC2ConfirmModalElementEventMap>(type: K, listener: (this: HTMLC2ConfirmModalElement, ev: C2ConfirmModalCustomEvent<HTMLC2ConfirmModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLC2ConfirmModalElementEventMap>(type: K, listener: (this: HTMLC2ConfirmModalElement, ev: C2ConfirmModalCustomEvent<HTMLC2ConfirmModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLC2ConfirmModalElement: {
        prototype: HTMLC2ConfirmModalElement;
        new (): HTMLC2ConfirmModalElement;
    };
    /**
     * Copies the text passed as a child when clicked.
     */
    interface HTMLC2CopyElement extends Components.C2Copy, HTMLStencilElement {
    }
    var HTMLC2CopyElement: {
        prototype: HTMLC2CopyElement;
        new (): HTMLC2CopyElement;
    };
    /**
     * Display a banner with text in the corner.
     */
    interface HTMLC2CornerBannerElement extends Components.C2CornerBanner, HTMLStencilElement {
    }
    var HTMLC2CornerBannerElement: {
        prototype: HTMLC2CornerBannerElement;
        new (): HTMLC2CornerBannerElement;
    };
    /**
     * A pill display of an number, that pulses on change. Caps out at 999.
     */
    interface HTMLC2CounterElement extends Components.C2Counter, HTMLStencilElement {
    }
    var HTMLC2CounterElement: {
        prototype: HTMLC2CounterElement;
        new (): HTMLC2CounterElement;
    };
    /**
     * Punches a hole through all parent shadow DOMs into the light DOM.
     * Any slotted chlid will be moved into the light, and a chain of slots
     * brings the slotted children back into position.
     */
    interface HTMLC2HolePuncherElement extends Components.C2HolePuncher, HTMLStencilElement {
    }
    var HTMLC2HolePuncherElement: {
        prototype: HTMLC2HolePuncherElement;
        new (): HTMLC2HolePuncherElement;
    };
    /**
     * Displays an icon loaded from the `iconStore`. An icon named "spinner" will automatically spin.
     * See [IconStore](/components/variables/iconStore) for details on how to load icons.
     */
    interface HTMLC2IconElement extends Components.C2Icon, HTMLStencilElement {
    }
    var HTMLC2IconElement: {
        prototype: HTMLC2IconElement;
        new (): HTMLC2IconElement;
    };
    /**
     * Display a row of five pulsing dots, to indicate loading.
     */
    interface HTMLC2LoadingDotsElement extends Components.C2LoadingDots, HTMLStencilElement {
    }
    var HTMLC2LoadingDotsElement: {
        prototype: HTMLC2LoadingDotsElement;
        new (): HTMLC2LoadingDotsElement;
    };
    /**
     * Displays a grey block to placehold loading text.
     */
    interface HTMLC2LoadingTextElement extends Components.C2LoadingText, HTMLStencilElement {
    }
    var HTMLC2LoadingTextElement: {
        prototype: HTMLC2LoadingTextElement;
        new (): HTMLC2LoadingTextElement;
    };
    interface HTMLC2ModalElementEventMap {
        "requestClose": void;
    }
    /**
     * A pop up modal for overlaying information, warnings and confirmations.
     * Traps focus within the modal, and returns focus to previous location when closed.
     * Pair with an [`c2-portal`](/components/components/portal) to open and close.
     */
    interface HTMLC2ModalElement extends Components.C2Modal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLC2ModalElementEventMap>(type: K, listener: (this: HTMLC2ModalElement, ev: C2ModalCustomEvent<HTMLC2ModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLC2ModalElementEventMap>(type: K, listener: (this: HTMLC2ModalElement, ev: C2ModalCustomEvent<HTMLC2ModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLC2ModalElement: {
        prototype: HTMLC2ModalElement;
        new (): HTMLC2ModalElement;
    };
    interface HTMLC2PaginationElementEventMap {
        "update": PageChangeEventType;
    }
    /**
     * Page navigation with ability to jump to first and last pages with `pageCount` is provided.
     */
    interface HTMLC2PaginationElement extends Components.C2Pagination, HTMLStencilElement {
        addEventListener<K extends keyof HTMLC2PaginationElementEventMap>(type: K, listener: (this: HTMLC2PaginationElement, ev: C2PaginationCustomEvent<HTMLC2PaginationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLC2PaginationElementEventMap>(type: K, listener: (this: HTMLC2PaginationElement, ev: C2PaginationCustomEvent<HTMLC2PaginationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLC2PaginationElement: {
        prototype: HTMLC2PaginationElement;
        new (): HTMLC2PaginationElement;
    };
    interface HTMLC2PopoverElementEventMap {
        "requestClose": any;
    }
    /**
     * Attaches a portaled popover, attached to the parent node. Can be used to create dropdowns, tooltips etc. The parent scoped shadow styles are copied to the created portals shadow styles, to allow styling popover contents externally.
     */
    interface HTMLC2PopoverElement extends Components.C2Popover, HTMLStencilElement {
        addEventListener<K extends keyof HTMLC2PopoverElementEventMap>(type: K, listener: (this: HTMLC2PopoverElement, ev: C2PopoverCustomEvent<HTMLC2PopoverElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLC2PopoverElementEventMap>(type: K, listener: (this: HTMLC2PopoverElement, ev: C2PopoverCustomEvent<HTMLC2PopoverElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLC2PopoverElement: {
        prototype: HTMLC2PopoverElement;
        new (): HTMLC2PopoverElement;
    };
    interface HTMLC2PopperElementEventMap {
        "requestClose": any;
    }
    interface HTMLC2PopperElement extends Components.C2Popper, HTMLStencilElement {
        addEventListener<K extends keyof HTMLC2PopperElementEventMap>(type: K, listener: (this: HTMLC2PopperElement, ev: C2PopperCustomEvent<HTMLC2PopperElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLC2PopperElementEventMap>(type: K, listener: (this: HTMLC2PopperElement, ev: C2PopperCustomEvent<HTMLC2PopperElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLC2PopperElement: {
        prototype: HTMLC2PopperElement;
        new (): HTMLC2PopperElement;
    };
    interface HTMLC2PopperInnerElement extends Components.C2PopperInner, HTMLStencilElement {
    }
    var HTMLC2PopperInnerElement: {
        prototype: HTMLC2PopperInnerElement;
        new (): HTMLC2PopperInnerElement;
    };
    interface HTMLC2PopperXElement extends Components.C2PopperX, HTMLStencilElement {
    }
    var HTMLC2PopperXElement: {
        prototype: HTMLC2PopperXElement;
        new (): HTMLC2PopperXElement;
    };
    interface HTMLC2PopperYElement extends Components.C2PopperY, HTMLStencilElement {
    }
    var HTMLC2PopperYElement: {
        prototype: HTMLC2PopperYElement;
        new (): HTMLC2PopperYElement;
    };
    interface HTMLC2PortalElementEventMap {
        "requestClose": any;
    }
    /**
     * Portals the passed node to a different part of the document. Note that portal does not transfer shadow scoped styles, unlike `c2-popover`, so any portaled elements should be self contained.
     */
    interface HTMLC2PortalElement extends Components.C2Portal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLC2PortalElementEventMap>(type: K, listener: (this: HTMLC2PortalElement, ev: C2PortalCustomEvent<HTMLC2PortalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLC2PortalElementEventMap>(type: K, listener: (this: HTMLC2PortalElement, ev: C2PortalCustomEvent<HTMLC2PortalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLC2PortalElement: {
        prototype: HTMLC2PortalElement;
        new (): HTMLC2PortalElement;
    };
    interface HTMLC2ProgressionElementEventMap {
        "progressionRequest": string;
    }
    /**
     * A wizard progression bar.
     */
    interface HTMLC2ProgressionElement extends Components.C2Progression, HTMLStencilElement {
        addEventListener<K extends keyof HTMLC2ProgressionElementEventMap>(type: K, listener: (this: HTMLC2ProgressionElement, ev: C2ProgressionCustomEvent<HTMLC2ProgressionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLC2ProgressionElementEventMap>(type: K, listener: (this: HTMLC2ProgressionElement, ev: C2ProgressionCustomEvent<HTMLC2ProgressionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLC2ProgressionElement: {
        prototype: HTMLC2ProgressionElement;
        new (): HTMLC2ProgressionElement;
    };
    interface HTMLC2ResizeObserverElementEventMap {
        "sizeChanged": DOMRectReadOnly;
    }
    /**
     * Wraps a [ResizeObserver](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver) to allow tracking `DOMRect` dimensions
     */
    interface HTMLC2ResizeObserverElement extends Components.C2ResizeObserver, HTMLStencilElement {
        addEventListener<K extends keyof HTMLC2ResizeObserverElementEventMap>(type: K, listener: (this: HTMLC2ResizeObserverElement, ev: C2ResizeObserverCustomEvent<HTMLC2ResizeObserverElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLC2ResizeObserverElementEventMap>(type: K, listener: (this: HTMLC2ResizeObserverElement, ev: C2ResizeObserverCustomEvent<HTMLC2ResizeObserverElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLC2ResizeObserverElement: {
        prototype: HTMLC2ResizeObserverElement;
        new (): HTMLC2ResizeObserverElement;
    };
    interface HTMLC2TableElementEventMap {
        "clickRow": ClickRow<any>;
        "clickSort": string;
    }
    /**
     * Create a table from data.
     */
    interface HTMLC2TableElement extends Components.C2Table, HTMLStencilElement {
        addEventListener<K extends keyof HTMLC2TableElementEventMap>(type: K, listener: (this: HTMLC2TableElement, ev: C2TableCustomEvent<HTMLC2TableElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLC2TableElementEventMap>(type: K, listener: (this: HTMLC2TableElement, ev: C2TableCustomEvent<HTMLC2TableElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLC2TableElement: {
        prototype: HTMLC2TableElement;
        new (): HTMLC2TableElement;
    };
    /**
     * Render a single row data as a grid of information.
     */
    interface HTMLC2TableDetailElement extends Components.C2TableDetail, HTMLStencilElement {
    }
    var HTMLC2TableDetailElement: {
        prototype: HTMLC2TableDetailElement;
        new (): HTMLC2TableDetailElement;
    };
    /**
     * A default header for [`c2-table-detail`](/components/components/table-detail).
     */
    interface HTMLC2TableDetailHeaderElement extends Components.C2TableDetailHeader, HTMLStencilElement {
    }
    var HTMLC2TableDetailHeaderElement: {
        prototype: HTMLC2TableDetailHeaderElement;
        new (): HTMLC2TableDetailHeaderElement;
    };
    interface HTMLC2TableNestedElementEventMap {
        "clickRow": any;
        "expansion": { data: any; key: string };
    }
    /**
     * Create a nested table from data.
     */
    interface HTMLC2TableNestedElement extends Components.C2TableNested, HTMLStencilElement {
        addEventListener<K extends keyof HTMLC2TableNestedElementEventMap>(type: K, listener: (this: HTMLC2TableNestedElement, ev: C2TableNestedCustomEvent<HTMLC2TableNestedElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLC2TableNestedElementEventMap>(type: K, listener: (this: HTMLC2TableNestedElement, ev: C2TableNestedCustomEvent<HTMLC2TableNestedElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLC2TableNestedElement: {
        prototype: HTMLC2TableNestedElement;
        new (): HTMLC2TableNestedElement;
    };
    interface HTMLC2TableVirtualizedElementEventMap {
        "clickRow": ClickRow;
        "clickSort": string;
        "loadBlock": LoadWindow;
        "lastBlock": void;
        "firstBlock": void;
    }
    /**
     * Create a virtualized table from data.
     */
    interface HTMLC2TableVirtualizedElement extends Components.C2TableVirtualized, HTMLStencilElement {
        addEventListener<K extends keyof HTMLC2TableVirtualizedElementEventMap>(type: K, listener: (this: HTMLC2TableVirtualizedElement, ev: C2TableVirtualizedCustomEvent<HTMLC2TableVirtualizedElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLC2TableVirtualizedElementEventMap>(type: K, listener: (this: HTMLC2TableVirtualizedElement, ev: C2TableVirtualizedCustomEvent<HTMLC2TableVirtualizedElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLC2TableVirtualizedElement: {
        prototype: HTMLC2TableVirtualizedElement;
        new (): HTMLC2TableVirtualizedElement;
    };
    interface HTMLC2TabsElementEventMap {
        "tabChange": string;
    }
    /**
     * A tabbed panel. Each panel can be targeted via a slot.
     */
    interface HTMLC2TabsElement extends Components.C2Tabs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLC2TabsElementEventMap>(type: K, listener: (this: HTMLC2TabsElement, ev: C2TabsCustomEvent<HTMLC2TabsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLC2TabsElementEventMap>(type: K, listener: (this: HTMLC2TabsElement, ev: C2TabsCustomEvent<HTMLC2TabsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLC2TabsElement: {
        prototype: HTMLC2TabsElement;
        new (): HTMLC2TabsElement;
    };
    /**
     * A button with an icon that displays the state of a async action on click.
     */
    interface HTMLC2ThinkingButtonElement extends Components.C2ThinkingButton, HTMLStencilElement {
    }
    var HTMLC2ThinkingButtonElement: {
        prototype: HTMLC2ThinkingButtonElement;
        new (): HTMLC2ThinkingButtonElement;
    };
    interface HTMLC2ToastElement extends Components.C2Toast, HTMLStencilElement {
    }
    var HTMLC2ToastElement: {
        prototype: HTMLC2ToastElement;
        new (): HTMLC2ToastElement;
    };
    interface HTMLC2ToasterElement extends Components.C2Toaster, HTMLStencilElement {
    }
    var HTMLC2ToasterElement: {
        prototype: HTMLC2ToasterElement;
        new (): HTMLC2ToasterElement;
    };
    /**
     * A multi step wizard. Each step can be targeted via a slot.
     */
    interface HTMLC2WizardElement extends Components.C2Wizard, HTMLStencilElement {
    }
    var HTMLC2WizardElement: {
        prototype: HTMLC2WizardElement;
        new (): HTMLC2WizardElement;
    };
    interface HTMLElementTagNameMap {
        "c2-accordian": HTMLC2AccordianElement;
        "c2-action": HTMLC2ActionElement;
        "c2-action-dropdown": HTMLC2ActionDropdownElement;
        "c2-action-link": HTMLC2ActionLinkElement;
        "c2-action-with-confirmation": HTMLC2ActionWithConfirmationElement;
        "c2-actions": HTMLC2ActionsElement;
        "c2-backdrop": HTMLC2BackdropElement;
        "c2-badge": HTMLC2BadgeElement;
        "c2-button": HTMLC2ButtonElement;
        "c2-button-link": HTMLC2ButtonLinkElement;
        "c2-button-with-confirmation": HTMLC2ButtonWithConfirmationElement;
        "c2-callout": HTMLC2CalloutElement;
        "c2-confirm-modal": HTMLC2ConfirmModalElement;
        "c2-copy": HTMLC2CopyElement;
        "c2-corner-banner": HTMLC2CornerBannerElement;
        "c2-counter": HTMLC2CounterElement;
        "c2-hole-puncher": HTMLC2HolePuncherElement;
        "c2-icon": HTMLC2IconElement;
        "c2-loading-dots": HTMLC2LoadingDotsElement;
        "c2-loading-text": HTMLC2LoadingTextElement;
        "c2-modal": HTMLC2ModalElement;
        "c2-pagination": HTMLC2PaginationElement;
        "c2-popover": HTMLC2PopoverElement;
        "c2-popper": HTMLC2PopperElement;
        "c2-popper-inner": HTMLC2PopperInnerElement;
        "c2-popper-x": HTMLC2PopperXElement;
        "c2-popper-y": HTMLC2PopperYElement;
        "c2-portal": HTMLC2PortalElement;
        "c2-progression": HTMLC2ProgressionElement;
        "c2-resize-observer": HTMLC2ResizeObserverElement;
        "c2-table": HTMLC2TableElement;
        "c2-table-detail": HTMLC2TableDetailElement;
        "c2-table-detail-header": HTMLC2TableDetailHeaderElement;
        "c2-table-nested": HTMLC2TableNestedElement;
        "c2-table-virtualized": HTMLC2TableVirtualizedElement;
        "c2-tabs": HTMLC2TabsElement;
        "c2-thinking-button": HTMLC2ThinkingButtonElement;
        "c2-toast": HTMLC2ToastElement;
        "c2-toaster": HTMLC2ToasterElement;
        "c2-wizard": HTMLC2WizardElement;
    }
}
declare namespace LocalJSX {
    /**
     * Optionally collapsible sectioned view. Each section can be targeted via a part.
     */
    interface C2Accordian {
        /**
          * An array of sections to display.
         */
        "sections": AccordianSection[];
        /**
          * Display numbered counters beside each title.
         */
        "steps"?: boolean;
    }
    /**
     * A generic button action.
     */
    interface C2Action {
        /**
          * The action to take when the button is clicked.
         */
        "action": (e: MouseEvent) => any;
        /**
          * If the action should be disabled.
         */
        "disabled"?: boolean;
        /**
          * If a dot should be shown on the action, to indicate attention being required.
         */
        "dot"?: HTMLC2BadgeElement['color'];
        /**
          * If the action is within an `c2-action-dropdown`.
         */
        "dropdownItem"?: boolean;
        /**
          * The icon to show for the action.
         */
        "icon": IconDescription;
    }
    /**
     * A dropdown to display more actions than can be reasonably fit in a row.
     * All child actions must have the `dropdownItem` prop set.
     */
    interface C2ActionDropdown {
        /**
          * If the dropdown should be disabled.
         */
        "disabled"?: boolean;
        /**
          * The icon to show for the action.
         */
        "icon"?: IconDescription;
    }
    /**
     * A link action.
     */
    interface C2ActionLink {
        /**
          * If the action should be disabled.
         */
        "disabled"?: boolean;
        /**
          * If a dot should be shown on the action, to indicate attention being required.
         */
        "dot"?: HTMLC2BadgeElement['color'];
        /**
          * If the action is within an `c2-action-dropdown`.
         */
        "dropdownItem"?: boolean;
        /**
          * The icon to show for the action.
         */
        "icon": IconDescription;
        /**
          * The url to go to when clicked.
         */
        "url": string;
    }
    /**
     * An action with a confirmation modal.
     */
    interface C2ActionWithConfirmation {
        /**
          * The action to take when the button is clicked.
         */
        "action": () => any;
        /**
          * if the action should be disabled.
         */
        "disabled"?: boolean;
        /**
          * If a dot should be shown on the action, to indicate attention being required.
         */
        "dot"?: HTMLC2BadgeElement['color'];
        /**
          * If the action is within an `c2-action-dropdown`.
         */
        "dropdownItem"?: boolean;
        /**
          * The icon to show for the action.
         */
        "icon": IconDescription;
        /**
          * The text to display within the modal.
         */
        "modal": ConfirmModalOptions;
        /**
          * If the user needs to type the passed string to enable confirmation.
         */
        "typeToConfirm"?: string;
    }
    /**
     * A container for `c2-action-*` elements, to be used in tables or panel headers.
     */
    interface C2Actions {
    }
    interface C2Backdrop {
        "onClosed"?: (event: C2BackdropCustomEvent<any>) => void;
        "onRequestClose"?: (event: C2BackdropCustomEvent<any>) => void;
        "preventOverscroll"?: boolean;
        "showBackdrop"?: boolean;
    }
    /**
     * Display a counter or dot beside a component to indicate action being required.
     */
    interface C2Badge {
        /**
          * Choose the color variant of the badge
         */
        "color"?: HTMLC2CounterElement['color'];
        /**
          * What number to display in the counter (or if the dot should display)
         */
        "count": number;
        /**
          * Show the dot and counter even if the count 0 (or negative)
         */
        "showZero"?: boolean;
        /**
          * The base size (in px) of the counter (has no effect on the dot)
         */
        "size"?: number;
        /**
          * Select the display variant of the badge
         */
        "variant"?: BadgeVariant;
    }
    /**
     * A button.
     */
    interface C2Button {
        /**
          * If the button is disabled. Prevents the user from interacting with the button: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * The default behavior of the button.
         */
        "type"?: string;
        /**
          * Which styling variant to use.
         */
        "variant"?: ButtonVariant;
    }
    /**
     * Anchor link version of c2-button, wraps a `Link` from `@kurrent-ui/router`.
     */
    interface C2ButtonLink {
        /**
          * Class for the contained anchor element
         */
        "anchorClass"?: string;
        /**
          * Id for the contained anchor element
         */
        "anchorId"?: string;
        /**
          * Role for the contained anchor element
         */
        "anchorRole"?: string;
        /**
          * Tab Index for the contained anchor element
         */
        "anchorTabIndex"?: string;
        /**
          * Title for the contained anchor element
         */
        "anchorTitle"?: string;
        /**
          * If the link is disabled. Prevents the user from interacting with the link: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * Link is for an external site
         */
        "external"?: boolean;
        /**
          * If the button should navigate within the router context, or force a refresh.
         */
        "forceRefresh"?: boolean;
        /**
          * Target for link (eg: target="_blank")
         */
        "target"?: string;
        /**
          * Where the button should link to.
         */
        "url"?: string;
        /**
          * Which styling variant to use
         */
        "variant"?: ButtonVariant;
    }
    /**
     * A button with a confirmation modal.
     */
    interface C2ButtonWithConfirmation {
        /**
          * The action to be called on click.
         */
        "action": () => any;
        /**
          * If the button is disabled. Prevents the user from interacting with the button: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * The text to display within the modal.
         */
        "modal": ConfirmModalOptions;
        /**
          * The default behavior of the button.
         */
        "type"?: string;
        /**
          * If the user needs to type the passed string to enable confirmation.
         */
        "typeToConfirm"?: string;
        /**
          * Which styling variant to use.
         */
        "variant"?: ButtonVariant;
    }
    /**
     * Calls out a piece of information.
     */
    interface C2Callout {
        /**
          * Heading text.
         */
        "heading": string;
        /**
          * Override the variant icon.
         */
        "icon"?: IconDescription;
        /**
          * Which color set to use.
         */
        "variant"?: EsCalloutVariant;
    }
    /**
     * A modal to confirm an action.
     */
    interface C2ConfirmModal {
        /**
          * Text or component to display in the body of the modal.
         */
        "body": string | FunctionalComponent;
        /**
          * Text to display within the confirm button.
         */
        "confirm": string;
        /**
          * Button variant for the confirm button.
         */
        "confirmVariant"?: ButtonVariant;
        /**
          * Text to display in the heading.
         */
        "heading": string;
        /**
          * Triggered when the user has indicated that they want to close the modal.
         */
        "onRequestClose"?: (event: C2ConfirmModalCustomEvent<any>) => void;
        /**
          * Triggered when the user has indicated that they want to close the modal.
         */
        "onRequestDeletion"?: (event: C2ConfirmModalCustomEvent<any>) => void;
        /**
          * Text to display above the heading.
         */
        "preHeading": string;
        /**
          * String required to be typed to enable the confirm button.
         */
        "typeToConfirm"?: string;
        /**
          * Text to display in red below the body.
         */
        "warning"?: string;
    }
    /**
     * Copies the text passed as a child when clicked.
     */
    interface C2Copy {
    }
    /**
     * Display a banner with text in the corner.
     */
    interface C2CornerBanner {
        /**
          * Which styling variant to use.
         */
        "variant"?: CornerBannerVariant;
        /**
          * X location of the banner.
         */
        "x"?: 'left' | 'right';
        /**
          * Y location of the banner
         */
        "y"?: 'top' | 'bottom';
    }
    /**
     * A pill display of an number, that pulses on change. Caps out at 999.
     */
    interface C2Counter {
        /**
          * Choose the color variant of the counter
         */
        "color"?: CounterColor;
        /**
          * The number to display
         */
        "count"?: number;
        /**
          * The height of the counter that the rest of the dimensions scale from
         */
        "size"?: number;
        /**
          * The display style of the counter.
         */
        "variant"?: CounterVariant;
    }
    /**
     * Punches a hole through all parent shadow DOMs into the light DOM.
     * Any slotted chlid will be moved into the light, and a chain of slots
     * brings the slotted children back into position.
     */
    interface C2HolePuncher {
        /**
          * Prefix the generated slot name, to allow easier identification in the DOM
         */
        "namePrefix"?: string;
    }
    /**
     * Displays an icon loaded from the `iconStore`. An icon named "spinner" will automatically spin.
     * See [IconStore](/components/variables/iconStore) for details on how to load icons.
     */
    interface C2Icon {
        /**
          * Rotate the icon to a speciied angle.
         */
        "angle"?: number;
        /**
          * Which icon to display.
         */
        "icon": IconDescription;
        /**
          * The hight and width to scale the icon to.
         */
        "size"?: number;
        /**
          * Apply a spin animation.
         */
        "spin"?: boolean;
        /**
          * When spinning, should it spin clockwise or anticlockwise.
         */
        "spinDirection"?: 'clockwise' | 'antiClockwise';
    }
    /**
     * Display a row of five pulsing dots, to indicate loading.
     */
    interface C2LoadingDots {
    }
    /**
     * Displays a grey block to placehold loading text.
     */
    interface C2LoadingText {
        /**
          * The expected loaded text length.
         */
        "expectedLength": number;
        /**
          * Adds a random number of chars (up to the passed amount)
         */
        "variance"?: number;
    }
    /**
     * A pop up modal for overlaying information, warnings and confirmations.
     * Traps focus within the modal, and returns focus to previous location when closed.
     * Pair with an [`c2-portal`](/components/components/portal) to open and close.
     */
    interface C2Modal {
        /**
          * If the modal should have a footer.
         */
        "footer"?: boolean;
        /**
          * If the modal should have a header.
         */
        "header"?: boolean;
        /**
          * Triggers when the modal requests to be closed.
         */
        "onRequestClose"?: (event: C2ModalCustomEvent<void>) => void;
    }
    /**
     * Page navigation with ability to jump to first and last pages with `pageCount` is provided.
     */
    interface C2Pagination {
        /**
          * Current Page.
         */
        "current": number;
        /**
          * Triggered when a pagination button is clicked
         */
        "onUpdate"?: (event: C2PaginationCustomEvent<PageChangeEventType>) => void;
        /**
          * Number of pages.
         */
        "pageCount"?: number;
    }
    /**
     * Attaches a portaled popover, attached to the parent node. Can be used to create dropdowns, tooltips etc. The parent scoped shadow styles are copied to the created portals shadow styles, to allow styling popover contents externally.
     */
    interface C2Popover {
        /**
          * If the popover should render an arrow.
         */
        "arrow"?: boolean;
        /**
          * Pass an element to attach the popover to. (Defaults to the parent element.)
         */
        "attachTo"?: HTMLElement;
        /**
          * Constrain the size of the popover to the size of the attachment node.
         */
        "autoSize"?: Constrain;
        /**
          * If the popover should overlay a backdrop, to prevent external clicks.
         */
        "backdrop"?: boolean;
        /**
          * If the popover should request to close when focus is lost
         */
        "closeOnBlur"?: boolean;
        /**
          * If the popover should request to close when clicked outside
         */
        "closeOnClickOutside"?: boolean;
        /**
          * If the popover should request to close when esc is pressed
         */
        "closeOnEsc"?: boolean;
        /**
          * If the popover should request to close when the attachment element scrolls out of view
         */
        "closeOnScrollEscape"?: boolean;
        /**
          * Constrain the size of the popover inner to the size of the window.
         */
        "constrain"?: Constrain;
        /**
          * An array of allowed placements or enable / disable
         */
        "flip"?: Placement[] | boolean;
        /**
          * If the popover should hide itself when the attachment element scrolls out of view
         */
        "hideOnScrollEscape"?: boolean;
        /**
          * The maximum height to constrain to.
         */
        "maxHeight"?: number;
        /**
          * The maximum width to constrain to.
         */
        "maxWidth"?: number;
        /**
          * The offset away from the attachement element in px.
         */
        "offset"?: number;
        /**
          * Triggers when the popover requests to close.
         */
        "onRequestClose"?: (event: C2PopoverCustomEvent<any>) => void;
        /**
          * Toggles if the popover is open or not.
         */
        "open"?: boolean;
        /**
          * Where to place the popover in relation to the attachment point.
         */
        "placement"?: Placement;
        /**
          * Class name for the popper
         */
        "popperClass"?: string;
        /**
          * A query selecter to select the element to portal the popper to.
         */
        "target"?: string;
        /**
          * If the popover should trap focus within, and return focus on close.
         */
        "trapFocus"?: boolean;
        /**
          * What zIndex to place the popover in.
         */
        "zIndex"?: number;
    }
    interface C2Popper {
        "backdrop"?: boolean;
        "onRequestClose"?: (event: C2PopperCustomEvent<any>) => void;
        "trapFocus"?: boolean;
    }
    interface C2PopperInner {
    }
    interface C2PopperX {
    }
    interface C2PopperY {
    }
    /**
     * Portals the passed node to a different part of the document. Note that portal does not transfer shadow scoped styles, unlike `c2-popover`, so any portaled elements should be self contained.
     */
    interface C2Portal {
        /**
          * If the portal should overlay a backdrop, to prevent external clicks.
         */
        "backdrop"?: boolean;
        /**
          * Triggers when the popover requests to close.
         */
        "onRequestClose"?: (event: C2PortalCustomEvent<any>) => void;
        /**
          * If the element is portaled or not.
         */
        "open"?: boolean;
        /**
          * If the portal should prevent overscroll
         */
        "preventOverscroll"?: boolean;
        /**
          * The element to render.
         */
        "renderElement": RenderFunction;
        /**
          * A query selector to select the location to portal to.
         */
        "target"?: string;
    }
    /**
     * A wizard progression bar.
     */
    interface C2Progression {
        /**
          * A list of checkpoints to display.
         */
        "checkpoints": Checkpoint[];
        /**
          * Set custom colors for all checkpoints
         */
        "colors"?: Partial<Record<CheckpointState, string>>;
        /**
          * Set custom icons for all checkpoints
         */
        "icons"?: Partial<Record<CheckpointState, IconDescription>>;
        /**
          * The current active location.
         */
        "location": string;
        /**
          * Emitted when a checkpoint is clicked.
         */
        "onProgressionRequest"?: (event: C2ProgressionCustomEvent<string>) => void;
        /**
          * Disable interactivity.
         */
        "readonly"?: boolean;
    }
    /**
     * Wraps a [ResizeObserver](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver) to allow tracking `DOMRect` dimensions
     */
    interface C2ResizeObserver {
        /**
          * Triggered when the size of the element changes.
         */
        "onSizeChanged"?: (event: C2ResizeObserverCustomEvent<DOMRectReadOnly>) => void;
    }
    /**
     * Create a table from data.
     */
    interface C2Table {
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any, any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: string[];
        /**
          * Pass extra props to cells
         */
        "extraCellProps"?: (key: string, data: any) => Record<string, any>;
        /**
          * Sync function for extracting the data from the row. By default, it assumes you passed an array of data as your columns.
         */
        "getCellData"?: (row: any) => any;
        /**
          * Sync function for extracting a key from your row data. By default, if the passed rows are strings it will use them directly, otherwise it will warn and use the index.
         */
        "getRowKey"?: (row: any, i: number) => string;
        /**
          * Do not render header.
         */
        "headless"?: boolean;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier"?: string;
        /**
          * A function to calculate a href from the cell data.
         */
        "linkRowTo"?: (data: any) => string;
        /**
          * Indicates if the loading indicators should be displayed
         */
        "loading"?: boolean;
        /**
          * Specifies the number of rows to display when loading is true. Defaults to 1.
         */
        "loadingRows"?: number;
        /**
          * Triggered whenever a row is clicked.
         */
        "onClickRow"?: (event: C2TableCustomEvent<ClickRow<any>>) => void;
        /**
          * Triggered whenever a sortable header is clicked
         */
        "onClickSort"?: (event: C2TableCustomEvent<string>) => void;
        /**
          * Allows rendering a node after the row.
         */
        "renderExpansion"?: RenderFunction<
        [row: any, key: string, i: number]
    >;
        /**
          * A function to calculate the class or classes of the row from the cellData.
         */
        "rowClass"?: (
        data: any,
        row: any,
    ) => Record<string, boolean> | string | undefined;
        /**
          * If rows should be allowed to take focus
         */
        "rowTakesFocus"?: boolean;
        /**
          * An array of rows to render. Each item in the array is passed to getCellData, to allow passing keys or other identifiers.
         */
        "rows": unknown[];
        /**
          * How the table is sorted
         */
        "sort"?: TableSort;
        /**
          * Header sticks to scroll parent.
         */
        "stickyHeader"?: boolean;
    }
    /**
     * Render a single row data as a grid of information.
     */
    interface C2TableDetail {
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any, any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: Array<string>;
        /**
          * The data to render.
         */
        "data": any;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier"?: string;
        /**
          * Indicates if the loading indicators should be displayed
         */
        "loading"?: boolean;
    }
    /**
     * A default header for [`c2-table-detail`](/components/components/table-detail).
     */
    interface C2TableDetailHeader {
        /**
          * Which cell to place in the top right as a list of actions.
         */
        "actionsCell"?: string;
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any, any>;
        /**
          * The data to render.
         */
        "data": any;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier"?: string;
        /**
          * Which cell to place as the title
         */
        "titleCell"?: string;
    }
    /**
     * Create a nested table from data.
     */
    interface C2TableNested {
        /**
          * A path to a the currently active row, to auto expand its parent and show it as selected.
         */
        "activePath"?: string[];
        /**
          * Function to decide if a row can take expand, to show a nested table.
         */
        "canExpand"?: (key: string, data: any, depth: number) => boolean;
        /**
          * Function to decide if a row can expand more, to show more rows in the nested table.
         */
        "canExpandMore"?: (key: string, count: number) => boolean;
        /**
          * A record of table cell definitions.Some built in cells are cells are available for use: - `--borderless`: A blank placeholder cell with no border, for aligning with the parent cell. - `--no-pad`: A blank placeholder cell, for aligning with the parent cell. - `--expander`: The expander button.
         */
        "cells": TableCells<any, any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: string[];
        /**
          * Number of rows to be expanded by default
         */
        "defaultExpanded"?: (key: string, depth: number) => number;
        /**
          * Number number of rows to display in expansion
         */
        "expandBy"?: number;
        /**
          * Pass extra props to cells
         */
        "extraCellProps"?: (key: string, data: any) => Record<string, any>;
        /**
          * Sync function for extracting the data from the row. By default, it assumes you passed an array of data as your columns.
         */
        "getCellData"?: (key: string) => any;
        /**
          * Sync function for extracting the data from the nested row. By default, it assumes you passed an array of data as your columns.
         */
        "getNestedCellData"?: (key: string) => any;
        /**
          * Sync function for extracting a key from your nested row data. By default, if the passed rows are strings it will use them directly, otherwise it will warn and use the index.
         */
        "getNestedRowKey"?: (row: any, i: number) => string;
        /**
          * Sync function for extracting a list of rows for the nested table
         */
        "getNestedRows"?: (key: string, count: number) => any[] | undefined;
        /**
          * Sync function for extracting a key from your row data. By default, if the passed rows are strings it will use them directly, otherwise it will warn and use the index.
         */
        "getRowKey"?: (row: any, i: number) => string;
        /**
          * Do not render header.
         */
        "headless"?: boolean;
        /**
          * A function to calculate a href from the cell data.
         */
        "linkRowTo"?: (row: any) => string;
        /**
          * async function for loading nested data when a row is expanded.
         */
        "loadNested"?: (key: string, data: any) => Promise<void>;
        /**
          * Indicates if the loading indicators should be displayed
         */
        "loading"?: boolean;
        /**
          * Specifies the number of rows to display when loading is true. Defaults to 1.
         */
        "loadingRows"?: number;
        /**
          * The order and keys of the cells to be rendered in a nested table. If omitted, all cells will be rendered.
         */
        "nestedColumns"?: string[];
        /**
          * Passed to cell renderer as `parent`.
         */
        "nestedIdentifier"?: string;
        /**
          * If the nested rows should be allowed to take focus.
         */
        "nestedRowTakesFocus"?: boolean;
        /**
          * Triggered whenever a row (or nested row) is clicked. The `detail` is the item in the row array.
         */
        "onClickRow"?: (event: C2TableNestedCustomEvent<any>) => void;
        /**
          * Triggered whenever a row is expanded.
         */
        "onExpansion"?: (event: C2TableNestedCustomEvent<{ data: any; key: string }>) => void;
        /**
          * Passed to cell renderer as `parent`.
         */
        "outerIdentifier"?: string;
        /**
          * A function to calculate the class or classes of the row from the cellData.
         */
        "rowClass"?: (
        row: any,
        key: string,
    ) => Record<string, boolean> | string | undefined;
        /**
          * If rows should be allowed to take focus
         */
        "rowTakesFocus"?: boolean;
        /**
          * An array of rows to render. Each item in the array is passed to getCellData, to allow passing keys or other identifiers.
         */
        "rows": any[];
        /**
          * Header sticks to scroll parent.
         */
        "stickyHeader"?: boolean;
        /**
          * If clicking a row should expand it.
         */
        "toggleRowOnClick"?: boolean;
    }
    /**
     * Create a virtualized table from data.
     */
    interface C2TableVirtualized {
        /**
          * The height (in pixels) of the after
         */
        "afterHeight"?: number;
        /**
          * The height (in pixels) of the before
         */
        "beforeHeight"?: number;
        /**
          * Groups rows into blocks
         */
        "blockSize"?: number;
        /**
          * A record of table cell definitions.
         */
        "cells": TableCells<any, any>;
        /**
          * The order and keys of the cells to be rendered. If omitted, all cells will be rendered.
         */
        "columns"?: string[];
        /**
          * Pass extra props to cells
         */
        "extraCellProps"?: (key: string, data: any) => Record<string, any>;
        /**
          * Sync function for extracting the data from the row. By default, it assumes you passed an array of data as your columns.
         */
        "getCellData": (key: string, index: number) => any;
        /**
          * Sync function for converting an index into a key
         */
        "getKeyFromIndex"?: (index: number) => string;
        /**
          * The height (in pixels) of the header
         */
        "headerHeight"?: number;
        /**
          * Do not render header.
         */
        "headless"?: boolean;
        /**
          * Passed to cell renderer as `parent`.
         */
        "identifier"?: string;
        /**
          * A function to calculate a href from the cell data.
         */
        "linkRowTo"?: (row: any) => string;
        /**
          * Triggered whenever a row is clicked. The `detail` is the item in the row array.
         */
        "onClickRow"?: (event: C2TableVirtualizedCustomEvent<ClickRow>) => void;
        /**
          * Triggered whenever a sortable header is clicked
         */
        "onClickSort"?: (event: C2TableVirtualizedCustomEvent<string>) => void;
        /**
          * Triggered when the first block is rendered
         */
        "onFirstBlock"?: (event: C2TableVirtualizedCustomEvent<void>) => void;
        /**
          * Triggered when the last block is rendered
         */
        "onLastBlock"?: (event: C2TableVirtualizedCustomEvent<void>) => void;
        /**
          * Triggered when a block is rendered
         */
        "onLoadBlock"?: (event: C2TableVirtualizedCustomEvent<LoadWindow>) => void;
        /**
          * The size of the grid rows before starting a reflow
         */
        "reflowSize"?: number;
        /**
          * Display in a row after the last row
         */
        "renderAfter"?: RenderFunction;
        /**
          * Display in a row before the first row
         */
        "renderBefore"?: RenderFunction;
        /**
          * A function to calculate the class or classes of the row from the cellData.
         */
        "rowClass"?: (
        row: any,
        key: string,
        index: number,
    ) => Record<string, boolean> | string | undefined;
        /**
          * The total number of rows
         */
        "rowCount": number;
        /**
          * The height (in pixels) of the row
         */
        "rowHeight"?: number;
        /**
          * If rows should be allowed to take focus
         */
        "rowTakesFocus"?: boolean;
        /**
          * If the table should lock scroll on appending events
         */
        "scrollLock"?: boolean;
        /**
          * How the table is sorted
         */
        "sort"?: TableSort;
        /**
          * Header sticks to scroll parent.
         */
        "stickyHeader"?: boolean;
        /**
          * The size of the window to render
         */
        "windowSize"?: number;
    }
    /**
     * A tabbed panel. Each panel can be targeted via a slot.
     */
    interface C2Tabs {
        /**
          * The currently active panel. By default it will take from the passed activeParam, or the first tab.
         */
        "active"?: string;
        /**
          * Reflect the active tab to a search param of name. Set to false to disable.
         */
        "activeParam"?: string | false;
        /**
          * Icon to be rendered between each tab.
         */
        "interTabIcon"?: IconDescription;
        /**
          * thu size of the icon to be rendered between each tab.
         */
        "interTabIconSize"?: number;
        /**
          * Triggered when the active tab is changed. `detail` is the newly active tab.
         */
        "onTabChange"?: (event: C2TabsCustomEvent<string>) => void;
        /**
          * A list of tabs.
         */
        "tabs": Tab[];
    }
    /**
     * A button with an icon that displays the state of a async action on click.
     */
    interface C2ThinkingButton {
        /**
          * The async action to be called on click.
         */
        "action": (e: MouseEvent) => Promise<unknown>;
        /**
          * The icon to display when the action completed successfully.
         */
        "completeIcon"?: IconDescription;
        /**
          * The default icon to display when nothing is happening.
         */
        "defaultIcon": IconDescription;
        /**
          * If the button is disabled. Prevents the user from interacting with the button: it cannot be pressed or focused.
         */
        "disabled"?: boolean;
        /**
          * The icon to display when the action errored out.
         */
        "failedIcon"?: IconDescription;
        /**
          * Optional text of the button
         */
        "text"?: string;
        /**
          * The icon to display when we are awaiting the action.
         */
        "thinkingIcon"?: IconDescription;
        /**
          * Which styling variant to use.
         */
        "variant"?: HTMLC2ButtonElement['variant'];
    }
    interface C2Toast {
        "count": Toast['count'];
        "icon": Toast['icon'];
        "level": ToastLevel;
    }
    interface C2Toaster {
    }
    /**
     * A multi step wizard. Each step can be targeted via a slot.
     */
    interface C2Wizard {
        /**
          * The currently active page
         */
        "location": string;
        /**
          * A list of pages describing each step.
         */
        "pages": WizardPage[];
        /**
          * Offset the scroll to top on page change
         */
        "scrollOffset"?: number;
    }
    interface IntrinsicElements {
        "c2-accordian": C2Accordian;
        "c2-action": C2Action;
        "c2-action-dropdown": C2ActionDropdown;
        "c2-action-link": C2ActionLink;
        "c2-action-with-confirmation": C2ActionWithConfirmation;
        "c2-actions": C2Actions;
        "c2-backdrop": C2Backdrop;
        "c2-badge": C2Badge;
        "c2-button": C2Button;
        "c2-button-link": C2ButtonLink;
        "c2-button-with-confirmation": C2ButtonWithConfirmation;
        "c2-callout": C2Callout;
        "c2-confirm-modal": C2ConfirmModal;
        "c2-copy": C2Copy;
        "c2-corner-banner": C2CornerBanner;
        "c2-counter": C2Counter;
        "c2-hole-puncher": C2HolePuncher;
        "c2-icon": C2Icon;
        "c2-loading-dots": C2LoadingDots;
        "c2-loading-text": C2LoadingText;
        "c2-modal": C2Modal;
        "c2-pagination": C2Pagination;
        "c2-popover": C2Popover;
        "c2-popper": C2Popper;
        "c2-popper-inner": C2PopperInner;
        "c2-popper-x": C2PopperX;
        "c2-popper-y": C2PopperY;
        "c2-portal": C2Portal;
        "c2-progression": C2Progression;
        "c2-resize-observer": C2ResizeObserver;
        "c2-table": C2Table;
        "c2-table-detail": C2TableDetail;
        "c2-table-detail-header": C2TableDetailHeader;
        "c2-table-nested": C2TableNested;
        "c2-table-virtualized": C2TableVirtualized;
        "c2-tabs": C2Tabs;
        "c2-thinking-button": C2ThinkingButton;
        "c2-toast": C2Toast;
        "c2-toaster": C2Toaster;
        "c2-wizard": C2Wizard;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * Optionally collapsible sectioned view. Each section can be targeted via a part.
             */
            "c2-accordian": LocalJSX.C2Accordian & JSXBase.HTMLAttributes<HTMLC2AccordianElement>;
            /**
             * A generic button action.
             */
            "c2-action": LocalJSX.C2Action & JSXBase.HTMLAttributes<HTMLC2ActionElement>;
            /**
             * A dropdown to display more actions than can be reasonably fit in a row.
             * All child actions must have the `dropdownItem` prop set.
             */
            "c2-action-dropdown": LocalJSX.C2ActionDropdown & JSXBase.HTMLAttributes<HTMLC2ActionDropdownElement>;
            /**
             * A link action.
             */
            "c2-action-link": LocalJSX.C2ActionLink & JSXBase.HTMLAttributes<HTMLC2ActionLinkElement>;
            /**
             * An action with a confirmation modal.
             */
            "c2-action-with-confirmation": LocalJSX.C2ActionWithConfirmation & JSXBase.HTMLAttributes<HTMLC2ActionWithConfirmationElement>;
            /**
             * A container for `c2-action-*` elements, to be used in tables or panel headers.
             */
            "c2-actions": LocalJSX.C2Actions & JSXBase.HTMLAttributes<HTMLC2ActionsElement>;
            "c2-backdrop": LocalJSX.C2Backdrop & JSXBase.HTMLAttributes<HTMLC2BackdropElement>;
            /**
             * Display a counter or dot beside a component to indicate action being required.
             */
            "c2-badge": LocalJSX.C2Badge & JSXBase.HTMLAttributes<HTMLC2BadgeElement>;
            /**
             * A button.
             */
            "c2-button": LocalJSX.C2Button & JSXBase.HTMLAttributes<HTMLC2ButtonElement>;
            /**
             * Anchor link version of c2-button, wraps a `Link` from `@kurrent-ui/router`.
             */
            "c2-button-link": LocalJSX.C2ButtonLink & JSXBase.HTMLAttributes<HTMLC2ButtonLinkElement>;
            /**
             * A button with a confirmation modal.
             */
            "c2-button-with-confirmation": LocalJSX.C2ButtonWithConfirmation & JSXBase.HTMLAttributes<HTMLC2ButtonWithConfirmationElement>;
            /**
             * Calls out a piece of information.
             */
            "c2-callout": LocalJSX.C2Callout & JSXBase.HTMLAttributes<HTMLC2CalloutElement>;
            /**
             * A modal to confirm an action.
             */
            "c2-confirm-modal": LocalJSX.C2ConfirmModal & JSXBase.HTMLAttributes<HTMLC2ConfirmModalElement>;
            /**
             * Copies the text passed as a child when clicked.
             */
            "c2-copy": LocalJSX.C2Copy & JSXBase.HTMLAttributes<HTMLC2CopyElement>;
            /**
             * Display a banner with text in the corner.
             */
            "c2-corner-banner": LocalJSX.C2CornerBanner & JSXBase.HTMLAttributes<HTMLC2CornerBannerElement>;
            /**
             * A pill display of an number, that pulses on change. Caps out at 999.
             */
            "c2-counter": LocalJSX.C2Counter & JSXBase.HTMLAttributes<HTMLC2CounterElement>;
            /**
             * Punches a hole through all parent shadow DOMs into the light DOM.
             * Any slotted chlid will be moved into the light, and a chain of slots
             * brings the slotted children back into position.
             */
            "c2-hole-puncher": LocalJSX.C2HolePuncher & JSXBase.HTMLAttributes<HTMLC2HolePuncherElement>;
            /**
             * Displays an icon loaded from the `iconStore`. An icon named "spinner" will automatically spin.
             * See [IconStore](/components/variables/iconStore) for details on how to load icons.
             */
            "c2-icon": LocalJSX.C2Icon & JSXBase.HTMLAttributes<HTMLC2IconElement>;
            /**
             * Display a row of five pulsing dots, to indicate loading.
             */
            "c2-loading-dots": LocalJSX.C2LoadingDots & JSXBase.HTMLAttributes<HTMLC2LoadingDotsElement>;
            /**
             * Displays a grey block to placehold loading text.
             */
            "c2-loading-text": LocalJSX.C2LoadingText & JSXBase.HTMLAttributes<HTMLC2LoadingTextElement>;
            /**
             * A pop up modal for overlaying information, warnings and confirmations.
             * Traps focus within the modal, and returns focus to previous location when closed.
             * Pair with an [`c2-portal`](/components/components/portal) to open and close.
             */
            "c2-modal": LocalJSX.C2Modal & JSXBase.HTMLAttributes<HTMLC2ModalElement>;
            /**
             * Page navigation with ability to jump to first and last pages with `pageCount` is provided.
             */
            "c2-pagination": LocalJSX.C2Pagination & JSXBase.HTMLAttributes<HTMLC2PaginationElement>;
            /**
             * Attaches a portaled popover, attached to the parent node. Can be used to create dropdowns, tooltips etc. The parent scoped shadow styles are copied to the created portals shadow styles, to allow styling popover contents externally.
             */
            "c2-popover": LocalJSX.C2Popover & JSXBase.HTMLAttributes<HTMLC2PopoverElement>;
            "c2-popper": LocalJSX.C2Popper & JSXBase.HTMLAttributes<HTMLC2PopperElement>;
            "c2-popper-inner": LocalJSX.C2PopperInner & JSXBase.HTMLAttributes<HTMLC2PopperInnerElement>;
            "c2-popper-x": LocalJSX.C2PopperX & JSXBase.HTMLAttributes<HTMLC2PopperXElement>;
            "c2-popper-y": LocalJSX.C2PopperY & JSXBase.HTMLAttributes<HTMLC2PopperYElement>;
            /**
             * Portals the passed node to a different part of the document. Note that portal does not transfer shadow scoped styles, unlike `c2-popover`, so any portaled elements should be self contained.
             */
            "c2-portal": LocalJSX.C2Portal & JSXBase.HTMLAttributes<HTMLC2PortalElement>;
            /**
             * A wizard progression bar.
             */
            "c2-progression": LocalJSX.C2Progression & JSXBase.HTMLAttributes<HTMLC2ProgressionElement>;
            /**
             * Wraps a [ResizeObserver](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver) to allow tracking `DOMRect` dimensions
             */
            "c2-resize-observer": LocalJSX.C2ResizeObserver & JSXBase.HTMLAttributes<HTMLC2ResizeObserverElement>;
            /**
             * Create a table from data.
             */
            "c2-table": LocalJSX.C2Table & JSXBase.HTMLAttributes<HTMLC2TableElement>;
            /**
             * Render a single row data as a grid of information.
             */
            "c2-table-detail": LocalJSX.C2TableDetail & JSXBase.HTMLAttributes<HTMLC2TableDetailElement>;
            /**
             * A default header for [`c2-table-detail`](/components/components/table-detail).
             */
            "c2-table-detail-header": LocalJSX.C2TableDetailHeader & JSXBase.HTMLAttributes<HTMLC2TableDetailHeaderElement>;
            /**
             * Create a nested table from data.
             */
            "c2-table-nested": LocalJSX.C2TableNested & JSXBase.HTMLAttributes<HTMLC2TableNestedElement>;
            /**
             * Create a virtualized table from data.
             */
            "c2-table-virtualized": LocalJSX.C2TableVirtualized & JSXBase.HTMLAttributes<HTMLC2TableVirtualizedElement>;
            /**
             * A tabbed panel. Each panel can be targeted via a slot.
             */
            "c2-tabs": LocalJSX.C2Tabs & JSXBase.HTMLAttributes<HTMLC2TabsElement>;
            /**
             * A button with an icon that displays the state of a async action on click.
             */
            "c2-thinking-button": LocalJSX.C2ThinkingButton & JSXBase.HTMLAttributes<HTMLC2ThinkingButtonElement>;
            "c2-toast": LocalJSX.C2Toast & JSXBase.HTMLAttributes<HTMLC2ToastElement>;
            "c2-toaster": LocalJSX.C2Toaster & JSXBase.HTMLAttributes<HTMLC2ToasterElement>;
            /**
             * A multi step wizard. Each step can be targeted via a slot.
             */
            "c2-wizard": LocalJSX.C2Wizard & JSXBase.HTMLAttributes<HTMLC2WizardElement>;
        }
    }
}
